SPItemBegin [keep format] = Alter Attribute
[
    PushOwner
    
        @if ( Equal( ObjectType, "Entity" ) )
        {
            Pop
            /* Current context is an attribute. */
            
            ShouldGenerate
            
            /* Process changes to attribute datatype */
            @if ( IsPropertyModified( "Physical_Data_Type" ) )
            {	
                @if ( NotEqual( [ PushOldImage [ Property( "Physical_Data_Type" ) ] Pop ], Property( "Physical_Data_Type" ) ) )
                {
                    SetLocalFlag( "Data Type Modified" )
                }
            }
            @if ( IsPropertyModified( "Parent_Domain_Ref" ) )
            {
                @if ( NotEqual( [ PushOldImage [ Property( "Physical_Data_Type" ) ] Pop ], Property( "Physical_Data_Type" ) ) )
                {
                    SetLocalFlag( "Data Type Modified" )
                }
            }
            @if ( IsPropertyModified( "Null_Option_Type" ) )
            {
                SetLocalFlag( "Data Type Modified" )
            }
            
            @if ( IsLocalFlagSet( "Data Type Modified" ) )
            {
                /* Check if the datatype can be altered */
                @if ( AllowAlterDatatype )
                {
                    SetLocalFlag( "Use Alter" )
                    
                    /* If null option was changed to NOT NULL/identity the datatype */
                    /* cannot be altered unless ALTER is forced by the user			*/
                    @if ( IsPropertyModified( "Null_Option_Type" ) )
                    {
                        @ifnot ( IsPropertyEqual(  "Null_Option_Type", "0" ) )
                        {
                            ClearLocalFlag( "Use Alter" )
                        }
                    }					
                }
                
                /* Check if user forces ALTER to be used */
                @if ( FE::Option( "AlterStatements" ) )
                {
                    SetLocalFlag( "Use Alter" )
                }

                /* ALTER cannot be used with timestamp datatype */
                @if ( Equal( Property( "Physical_Data_Type" ), "timestamp" ) )
                {
                    @if ( IsLocalFlagSet ( "Use Alter" ) )
                    {
                        ClearLocalFlag( "Use Alter" )
                    }
                }

                /* ALTER cannot be used if null option was changed to identity */
                @if ( IsPropertyModified( "Null_Option_Type" ) )
                {
                    @if ( IsPropertyEqual(  "Null_Option_Type", "8" ) )
                    {
                        ClearLocalFlag( "Use Alter" )
                    }
                }

                @if ( IsLocalFlagSet( "Use Alter" ) )
                {
                    /*Drop all indexes referenced by the column*/
                    [
                        ForEachReference( "Dependent_Objects_Ref", "require_one" )
                        {
                            Equal( ObjectType, "Key_Group_Member" )
                            [
                                PushTopLevelObject
                                [ Execute( "Drop Key_Group" ) ]
                                Pop
                            ]
                        }
                    ]
                    FE::Bucket( "90" )
                    PushOwner
                        FE::RecordAlter
                        "ALTER TABLE " 
                        [ FE::OwnerOverride( "true" ) "." ] 
                        QuotedName
                    Pop 
                    " "
                    "\n"
                    "   ALTER COLUMN " 
                    QuotedName 
                    " " 
                    Execute( "Clause: AttributeDatatype" ) 
                    [
                        " " IsPropertyModified( "Null_Option_Type" )
                        LookupProperty( "Null_Option_Type", "0", "NULL", "1", "NOT NULL" )
                    ]
                    FE::EndOfStatement
                    
                    /*Recreate all indexes referenced by the column*/
                    [
                        ForEachReference( "Dependent_Objects_Ref", "require_one" )
                        {
                            Equal( ObjectType, "Key_Group_Member" )
                            [
                                PushTopLevelObject
                                [
                                    Execute( "Create Key_Group" )
                                ]
                                Pop
                            ]
                        }
                    ]				
                }
                @else
                {
                    /* Drop/Recreate the entity. */
                    PushTopLevelObject
                    [ Execute( "Generate " ObjectType ) ]
                    Pop
                }
            }

	        /* Process the Physical Name (EMXTypes::pPhysicalNameX)	property of the attribute. */
	        [
		        IsPropertyModified( "Physical_Name", "Name" )
		        Execute( "Alter Object Physical Name" )
	        ]

	        /* Process the Row GUID	(EMXTypes::pRowGUID) property of the attribute.	*/
	        [
		        IsPropertyModified( "Row_GUID" )
		        /* Form the ALTER TABLE ALTER COLUMN DDL. */
		        [
			        FE::DataPreservationOption( "IsAlterRequired" )
			        Set( "var_AttIsCreated", "false" )
			        PushOwner
				        [
				            IsGlobalFlagSet( ObjectId "Create Attribute" ) 
				            Set( "var_AttIsCreated", "true" )
				        ]
				        [
				            PushOwner 
				            [
				                IsGlobalFlagSet( ObjectId "Create Entity" ) 
				                Set( "var_AttIsCreated", "true" )
				            ] 
				            Pop
				        ]
			        Pop
			        Equal( Value( "var_AttIsCreated" ), "false" )
        	
			        OnceForObject( "Alter Attribute RowGuid" )
        			
			        FE::Bucket( "90" )
			        FE::RecordAlter
			        PushOwner
				        "ALTER TABLE " 
				        [ FE::OwnerOverride( "true" ) "." ] 
				        QuotedName
			        Pop 
			        " "
			        "\n"
			        "   ALTER COLUMN " 
			        QuotedName 
			        " " 
			        LookupProperty( "Row_GUID", "1", "ADD", "DROP" ) 
			        " ROWGUIDCOL"
			        FE::EndOfStatement
		        ]
		        Remove( "var_AttIsCreated" )
	        ]

			[
				IsPropertyModified("SQLServer_XML_Schema_Collection_Ref") 
				[
					@if( [ PushOldImage IsPropertyNotNull( "SQLServer_XML_Schema_Collection_Ref" ) Pop] )
					{
						SetLocalFlag( "Use XML Schema" )
					}
					@if ( IsLocalFlagSet( "Use XML Schema" ) )
					{
						PushOwner
				    		"ALTER TABLE " 
				    		[ FE::OwnerOverride( "true" ) "." ] 
				    		QuotedName
			    		Pop 
						"   ALTER COLUMN "
						QuotedName " "
						Property("Physical_Data_Type")
						FE::EndOfStatement
					}
				]
			]
			/* Process The Comment for an Attribute  */
			[
				IsPropertyModified("Comment")
				Execute("Alter Comment")
				PushOwner
				[	
					Set("var_Level0Type", "SCHEMA")
					[ PushReference("Schema_Ref") Set("var_Level0Name", Property("Name")) Pop ]					
					Set("var_Level1Type", "TABLE")
					Set("var_Level1Name", Property("Physical_Name"))
			    ]
				Pop
				[
					Set("var_Level2Type", "COLUMN")					
					Set("var_ExtendedPropertyValue", Property("Comment"))
					Set("var_Level2Name", Property("Physical_Name"))
					Execute("Clause: Specify Extended Properties")
				]
			]
			/* To Handle FishHook Relationship */
			[
				IsPropertyModified("Physical_Lead_Attribute_Ref")		
				PushTopLevelObject
				[ Execute ( "Generate " ObjectType ) ]
				Pop
			]		
	        [
	            /* IsModified returns true if a property NOT in the parameter list was modified. */
		        @if ( FE::IsModified( "Comment", "Definition", "Physical_Data_Type", "Row_GUID", "Physical_Name", "Name", "Parent_Domain_Ref", "Null_Option_Type" ,"Physical_Lead_Attribute_Ref", "Parent_Attribute_Ref") )
		        {
			        PushTopLevelObject
			            [ Execute( "Generate " ObjectType ) ]
			        Pop
		        }
	        ]
	        PushOwner
	    }
        @elseif ( Equal( ObjectType, "View" ) )
        {
            /* View attribute was modified, recreate the view. */
            Execute( "Generate View" )
            
            /* We have the View, why are we pushing and poping? 
	        Pop 
                PushTopLevelObject 
                    Execute( "Generate " ObjectType )
                Pop
	        PushOwner
	        */
        }
    Pop
]
SPItemEnd

SPItemBegin [keep format] = Alter Check_Constraint_Usage
[
    /* -moved from Generic Alter- */
    Equal( ObjectType, "Check_Constraint_Usage" )
    ShouldGenerate
    
    Set( "var_ConstraintUsage", "undefined" )
	PushOwner
	    @if ( IsMatch( ObjectType, "Attribute", "Domain" ) )
        {
	        Set( "var_ConstraintUsage", "ColumnLevel" )
	    }
	    @elseif ( Equal( ObjectType, "Entity" ) )
        {
	        Set( "var_ConstraintUsage", "TableLevel" )
	    }
    Pop
    
    @if ( Equal( "var_ConstraintUsage", "ColumnLevel" ) )
    { 
        /* -- Alter Check Constraint Usage -- */
        Set( "var_bIsSQL92Format", "false" )
        [
            PushReference( "Validation_Rule_Ref" )
            [
                IsPropertyTrue( "Generate_As_SQL_92_Format" )
                Set( "var_bIsSQL92Format", "true" )
            ]
            Pop
        ]

        Set( "var_bIsOwnerDomain", "false" )
        [
            PushOwner
            [
                Equal( ObjectType, "Domain" )
                Set( "var_bIsOwnerDomain", "true" )
            ]
            Pop
        ]

        [
            Equal( Value( "var_bIsOwnerDomain" ), "false" )
            Equal( Value( "var_bIsSQL92Format" ) , "true" )


            /* Generate alter for disabled SQL 92 constraints. */
            [
                IsPropertyModified( "Is_Disabled" )
                FE::Bucket( "94" )
                FE::RecordAlter
                
                /* Set Table as context. */
                PushTopLevelObject  
                [
                    "ALTER TABLE " 
                    /* Name of the Table.*/
                    [ FE::OwnerOverride( "true" ) "." ]
                    < QuotedName >
                ]
                Pop
                
                /* Emit nocheck/check clause. */
                " "
                [ LookupProperty( "Is_Disabled", "true", "NO" ) ]
                "CHECK"
                
                /* Emit constraint name. */
                " CONSTRAINT " 
                < QuotedName >				
                [ FE::EndOfStatement ]
            ]

            /* Generate alter for WITH CHECK SQL 92 constraints. */
            [
                IsPropertyModified( "Force_Checking_Of_Existing_Data")
                FE::Bucket( "94" )
                FE::RecordAlter
                
                /* Set Table as context. */
                PushTopLevelObject  
                [
                    "ALTER TABLE " 
                    /* Name of the Table.*/
                    [ FE::OwnerOverride( "true" ) "." ]
                    < QuotedName >
                ]
                Pop
                
                /* Emit WITH CHECK/NO CHECK clause. */
                " WITH "
                < LookupProperty( "Force_Checking_Of_Existing_Data", "true", "CHECK", "false", "NOCHECK" ) >
                
                /* Emit constraint name. */
                " CONSTRAINT " 
                < QuotedName >				
                [ FE::EndOfStatement ]
            ]
        ]

        [
            /* True if something other than "Is_Disabled" and "Force_Checking_Of_Existing_Data" was modified. */
            @if ( IsModified( "Is_Disabled", "Force_Checking_Of_Existing_Data" ) )
            {
                Execute( "Generate Check_Constraint_Usage" )
            }
        ]
        
        Remove( "var_bIsOwnerDomain" )
        Remove( "var_bIsSQL92Format" )
    }
    @elseif ( Equal( "var_ConstraintUsage", "TableLevel" ) )
    {
        /* -- Alter Table Check Constraint Usage -- */
        [
            /* Generate alter for disabled SQL 92 constraints. */
            IsPropertyModified( "Is_Disabled" )
            FE::Bucket( "94" )
            FE::RecordAlter
            
            /* Set Table as context. */
            PushOwner  
            [
                "ALTER TABLE " 
                /* Name of the Table.*/
                [ FE::OwnerOverride( "true" ) "." ]
                < QuotedName >
            ]
            Pop
            
            /* Emit nocheck/check clause. */
            " "
            [ LookupProperty( "Is_Disabled", "true", "NO" ) ]
            "CHECK"
            /* Emit constraint name. */
            " CONSTRAINT " 
            < QuotedName >				
            FE::EndOfStatement
        ]
        
        [
            @if ( IsModified( "Is_Disabled" ) )
            {
                Execute( "Generate Table Check Constraint Usage" )
            }
        ]
    
    }
    Remove( "var_ConstraintUsage" )

]
SPItemEnd

SPItemBegin [keep format] = Alter Comment
/* Set the variables required by the "Clause: Specify Extended Properties". */

[
	Set("var_OldComment", PushOldImage Property("Comment") Pop) 
	NotEqual(Value( "var_OldComment" ),"")
	/* This Flag is set for Modifying the Property if it was present Previously */
	SetLocalFlag("Modify Extended Property")
]
@if(IsLocalFlagSet("Modify Extended Property"))
{
	Set("var_Operation", "sp_updateextendedproperty")	
	ClearLocalFlag("Modify Extended Property")	
}
@else
{
	Set("var_Operation", "sp_addextendedproperty")	
}
Set("var_RemoveVariables", "false") 
Set("var_Comment", "Comment")
SPItemEnd

SPItemBegin [keep format] = Alter Default
[    
	Equal( ObjectType, "Default" )
    [
	    /*Rename if the Default uses sp_binddefault*/
	    IsPropertyModified( "Physical_Name", "Name" )
	    IsPropertyFalse( "Generate_As_SQL_92_Format" )
	    Execute( "Alter Object Physical Name" )
    ]
	[
		/**Modify properties if the Default uses sp_binddefault*/
		/* Is something other than a name modified? */
		@if ( IsModified( "Physical_Name", "Name" ) )
		{
			IsPropertyFalse( "Generate_As_SQL_92_Format" )
			Execute( "Generate Default" )
		}
	]
	[
		/*Modify properties if the Validation rule uses SQL 92 format*/
		IsPropertyTrue( "Generate_As_SQL_92_Format" )
		[
			/* For each referring oDefaultConstraintUsage object, rebind the column. */
			<
			    ForEachReference( "Dependent_Objects_Ref" )
			    {
				    Execute( "Alter Default_Constraint_Usage" )
			    }
			>
		]
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Default_Constraint_Usage
[
    @if ( Equal( ObjectType, "Default" ) )
    {
	    /*Modify properties if the Validation rule uses SQL 92 format*/
	    @if ( IsPropertyTrue( "Generate_As_SQL_92_Format" ) )
	    {
		    /* For each referring oDefaultConstraintUsage object, rebind the column. */
	        ForEachReference( "Dependent_Objects_Ref", "require_one" )
	        {
		        Execute( "Generate Default_Constraint_Usage" )
	        }
	    }
	}
	@elseif ( Equal( ObjectType, "Default_Constraint_Usage" ) )
	{
	    Execute( "Generate Default_Constraint_Usage" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Domain
[
	Equal( ObjectType, "Domain" )
	IsPropertyTrue( "Generate_As_User_Defined_Type" )
	[
		IsPropertyModified( "Physical_Name", "Name" )
		Execute( "Alter Object Physical Name" )
	]

	[
		@if ( IsModified( "Physical_Name", "Name" ) )
		{
		    Execute( "Generate Domain" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Entity
[
	Equal( ObjectType, "Entity" )
	/* Process the Physical Name (EMXTypes::pPhysicalNameX)	property of the Entity.	*/
	[
	    IsPropertyModified( "Physical_Name", "Name" ) 
	    Execute( "Alter Object Physical Name" )
		/* Re-Create All existing dependent views so that their SQL */
	    /* definitions refer to the parent entity using the new name */
		ForEachReference("Parent_Relationships_Ref")
		{
			PushReference("Child_Entity_Ref")
			[
				Equal(ObjectType,"View")
				@ifnot(IsCreated)
				{
					Execute("Generate View")
				}
			]
			Pop
		}
	]

	[
		IsPropertyModified( "Schema_Ref" )
		FE::Bucket( "28" )
		FE::RecordAlter 
		"ALTER SCHEMA " 
		PushReference( "Schema_Ref" ) 
		    QuotedName 
		Pop
		"\n" 
		"TRANSFER " 
		PushOldImage
		    PushReference( "Schema_Ref" ) 
		        [ QuotedName ]
		    Pop
		Pop 
		"."
		QuotedName
		FE::EndOfStatement
	]

	/* Process the	(EMXTypes::pPhysicalOrderList) property of the Entity. */
	[
		IsPropertyModified( "Physical_Columns_Order_Ref" )
		FE::Option( "ColumnPhysicalOrder" )
		[
			IsPropertyReordered( "Physical_Columns_Order_Ref" )
			Execute( "Generate Entity" )
		]
	]

	/* Process the	(EMXTypes::pColumnOrderList) property of the Entity. */
	[
		IsPropertyModified( "Columns_Order_Ref" )
		[
			FE::Option( "!ColumnPhysicalOrder" )
			IsPropertyReordered( "Columns_Order_Ref" )
			Execute( "Generate Entity" )
		]
	]
	[
		IsPropertyModified("Comment")
		[					
			Execute("Alter Comment")
			Set("var_Level0Type", "SCHEMA")
			[ PushReference("Schema_Ref") Set("var_Level0Name", Property("Name")) Pop ]					
			Set("var_Level1Type", "TABLE")
			Set("var_Level1Name", Property("Physical_Name"))
			/* Generate Table comments and UDPs */
			Execute("Clause: Specify Extended Properties")
		]
	]	
	[
		@if ( FE::IsModified( "Comment", "Physical_Name", "Schema_Ref", "Name", "Physical_Columns_Order_Ref", "Columns_Order_Ref", "Attributes_Order_Ref" ) )
		{
		    Execute( "Generate Entity" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Function
	[
		FE::Bucket( "42" )
        
		Execute( "Generate Function" )
		
		/* Modify comments and UDP's as Extended Properties. */
		[
			/* Set the variables required by the "Clause: Specify Extended Properties". */
			Set( "var_RemoveVariables", "true" ) 
			Set( "var_Operation", "sp_updateextendedproperty" ) 
			Set( "var_Comment", "Definition" )
			Set( "var_Level0Type", "SCHEMA" )
			[ 
			PushReference( "Schema_Ref" ) 
			    Set( "var_Level0Name", Property( "Name" ) ) 
			Pop 
			]
			Set( "var_Level1Type", "FUNCTION") 
			Set( "var_Level1Name", Property( "Name" ) )
			
			/* Generate Function comments and UDPs */
			Execute( "Clause: Specify Extended Properties" )
		]
	]
SPItemEnd

SPItemBegin [keep format] = Alter Generic Create Object
Set( "var_ObjectType", ObjectType )
[
	Switch( Value( "var_ObjectType" ) )
	{			
	    Choose( "Attribute" )
		{
			PushOwner
				Equal( ObjectType, "Entity" ) 
			Pop
			Execute( "Create Attribute" )
		}
		Choose( "Check_Constraint_Usage" )
		{
			PushOwner
			[  
			    IsMatch( ObjectType, "Attribute", "Domain" )
				Pop
				    [ Execute( "Create Check_Constraint_Usage" ) ]
				PushOwner
			]
			[  
			    Equal( ObjectType,"Entity" )
				Pop
				    [ Execute( "Create Table Check Constraint Usage" ) ]
				PushOwner
			]
			Pop
		}
		Choose( "Default_Constraint_Usage" )
		{
			Execute( "Create Default_Constraint_Usage" )
		}
		Choose( "User_Id" )
		{
			Execute( "Create User_Id" )
		}
		Choose( "Trigger" )
		{
			Execute( "Create Trigger" )
		}
        Choose("Valid_Value")
        {
            PushOwner
            [
                Execute("Generate Validation_Rule")
            ]
            Pop
        }
		Default
		{
			PushTopLevelObject
			    @if ( IsCreated )
			    {
			        Execute( "Create " Value( "var_ObjectType" ) )
			    }
			    @else 
			    { 
			        Execute( "Generate " Value( "var_ObjectType" ) )
			    }
			Pop
		}
	}
]
Remove( "var_ObjectType" )
SPItemEnd

SPItemBegin [keep format] = Alter Generic Drop Object
	@if ( Equal( ObjectType, "Attribute" ) )
	{	
		PushOwner
		    @if ( Equal( ObjectType, "Entity" ) )
		    {
			    Pop 
			        Execute( "Drop Attribute" ) 
			    PushOwner
		    }
		Pop
	}
	@elseif ( Equal( ObjectType, "Default_Constraint_Usage" ) )
	{
		Execute( "Drop Default_Constraint_Usage" )
	}
	@elseif ( Equal( ObjectType, "Check_Constraint_Usage" ) )
	{
		PushOwner
		[
			IsMatch( ObjectType, "Attribute", "Domain" )
			Pop
			    Execute( "Drop Check_Constraint_Usage" )
			PushOwner
		]
		[  
			Equal( ObjectType,"Entity" )
			Pop
			    Execute( "Drop Table Check Constraint Usage" )
			PushOwner
		]
		Pop
	}
    @elseif( Equal( ObjectType, "Valid_Value" ) )
    {     
        PushOwner
        [
            /* Do not generate validation rule if it is deleted. */
            @if( IsDeleted )
            {
            }
            @else
            {
                Execute("Generate Validation_Rule")
            }
        ]
        Pop
    }
	@else
	{
		PushTopLevelObject
		    @if ( IsDeleted )
		    {
			    Execute( "Drop " ObjectType )
		    }
		    @else
		    {
			    Execute( "Generate " ObjectType )
		    }
		Pop
	}
SPItemEnd

SPItemBegin [keep format] = Alter Generic Modify Object
[
    [ 
        Execute( "Alter " ObjectType )
        SetLocalFlag( "Template Found" )
    ]
    [
        Equal(ObjectType, "Valid Value")
        [
            PushOwner
            [
                ExecuteX("Generate Validation_Rule")
                SetLocalFlag( "Template Found" )
            ]
            PopX
        ]
    ]

    @ifnot ( IsLocalFlagSet( "Template Found" ) )
    {
        PushTopLevelObject
            [ Execute( "Generate " ObjectType ) ]
        Pop
    }
    @else 
    {
        ClearLocalFlag( "Template Found" )
    }

]
SPItemEnd

SPItemBegin [keep format] = Alter Key_Group
[
	Equal( ObjectType, "Key_Group" )
	/* Process the Physical Name (EMXTypes::pPhysicalNameX)	property of the Key Group. */
	[
	    IsPropertyModified( "Physical_Name", "Name" ) 
	    Execute( "Alter Object Physical Name" )
	]

	[
		@if ( IsModified( "Physical_Name", "Name", "Key_Group_Members_Order_Ref" ) )
		{
		    Execute( "Generate Key_Group" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Object Physical Name
[
	OnceForObject( "Alter Object Physical Name" )
	NotEqual( [ Execute( "Previous Physical Name" ) ], [ Property( "Physical_Name" ) ] )
	FE::Bucket( "30" )
	FE::RecordAlter

	/*UNIQUE Constraint*/
	[
		Equal( ObjectType, "Key_Group" )
		/*IsNotNullX(CompareStringsX(PropertyValueX("Key_Group_Type" ),"AK","2" ),"<FALSE>" )*/
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK"  ) 
		"execute sp_rename " 
		"'" 
		Execute( "Previous Physical Name" ) 
		"'" 
		", " 
		"'" 
		Property( "Physical_Name" ) 
		"'"
		", 'OBJECT'"
		FE::EndOfStatement
	]
	
	[
		[
			IsMatch( ObjectType, "Domain", "Entity", "View", "Trigger", "Default", "Validation_Rule", "Stored_Procedure", "Check_Constraint_Usage", "Relationship" )
			"execute sp_rename " 
			"'" 
			[
			    IsMatch( ObjectType, "Entity", "View" ) 
			    [ FE::OwnerOverride( "true" ) "." ]
			]
			Execute( "Previous Physical Name" ) 
			"'" 
			", " 
			"'" 
			QuotedName
			"'"
		]
		
		[
			IsMatch( ObjectType, "Attribute", "Key_Group" )
			"execute sp_rename " 
			"'" 
			PushOwner 
			    [ FE::OwnerOverride( "true" ) "." ]
			    Property( "Physical_Name" ) 
			Pop 
			"." 
			Execute( "Previous Physical Name" ) 
			"'" 
			", " 
			"'"
			Property( "Physical_Name" )
			"'"
		]
		Switch( ObjectType )
		{
			Choose( "Attribute" )
			{
				PushOwner 
				[
				    Equal( ObjectType, "Entity" ) 
				    ", 'COLUMN'"
				] 
				Pop
			}
			Choose( "Key_Group" )
			{
				", 'INDEX'"
			}
			Choose( "Domain" )
			{
				", 'USERDATATYPE'"
			}
			Default
			{
				", 'OBJECT'"
			}
		}
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Parameter
[
	Equal( ObjectType, "Parameter" )
    [
	    /* function and stored procedure parameter */
	    PushOwner 
	        Execute( "Generate " ObjectType ) 
	    Pop
    ]
]
SPItemEnd

SPItemBegin [keep format] = Alter Relationship
[
	Equal( ObjectType, "Relationship" )
	[
	    IsPropertyModified( "Physical_Name" ) 
	    Execute( "Alter Object Physical Name" )
	]

	[
		IsPropertyModified( "Alias_Name" )
		[
			PushReference( "Child_Entity_Ref" )
			[
				IsMatch( ObjectType, "View", "Cached_View" )
				Execute( "Generate View" )
			]
			Pop
		]
	]

	[
		@if ( IsModified( "Physical_Name", "Alias_Name" ) )
		{
		    ForEachReference( "Dependent_Objects_Ref", "require_one" )
		    {
			    Equal( ObjectType, "Key_Group" )
			    Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
			    [
				    Execute( "Drop Constraint" )
				    Execute( "Create Constraint" )
			    ]
		    }
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Aggregate
	Execute( "Drop SQLServer_Aggregate" )
	Execute( "Create SQLServer_Aggregate" )
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Application_Role
	[   /* Handle Name change. */
	    IsPropertyModified( "Name" )
	    FE::Bucket( "55" )
	    FE::RecordAlter
		"ALTER APPLICATION ROLE "
		<
			[	
				PushOldImage 
				    Property( "Name" ) 
				Pop
				"\n" 
				"WITH NAME = " 
				Property( "Name" )
			]
		>
		FE::EndOfStatement
	]
			
	[   
	    /* Handle Schema change. */
		IsPropertyModified( "Default_Schema_Ref" )
		FE::Bucket( "55" )
		FE::RecordAlter
		"ALTER APPLICATION ROLE "
		< QuotedName >  /* <-- NOT IN UNCONVERTED TEMPLATE */
		<    
			[	
				PushReference( "Default_Schema_Ref" ) 
				    "\n" 
				    "WITH DEFAULT_SCHEMA = " 
				    < QuotedName > 
				Pop
			]
		>
		FE::EndOfStatement
	]
	
	[
	    /* Handle Comment change. */
		IsPropertyModified( "Definition" )
		Execute( "Generate SQLServer_Application_Role" )
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Assembly
    [
        "ALTER ASSEMBLY "
        < QuotedName >
        
        <     
            /* Assembly option */
            [
                "\n" 
                "WITH" 
                "\n"
                <
                	Separator
                	(
                	    ",\n", 
		                /* Check if the permission set was modified.*/
		                [
			                IsPropertyModified( "Permission_Set_Type" ) 
			                [
				                "PERMISSION_SET = " 
				                <
					                @if ( Equal( Property( "Permission_Set_Type"), "External Access" ) )
					                { 
					                    "EXTERNAL_ACCESS" 
					                }
					                @else
					                { 
					                    UpperCase( Property( "Permission_Set_Type" ) ) 
					                }
				                >
			                ]
		                ],
	
		                /* Check if the visibility option was modified.*/
		                [
			                IsPropertyModified( "Allow_Use_By_Functions" ) 
			               	"VISIBILITY = " 
			                < LookupProperty( "Allow_Use_By_Functions", "true", "ON", "false", "OFF" ) >
		                ],
	                	
		                /* the unchecked data option is included in the command if set to true */
		                [ 
		                    IsPropertyTrue( "Unchecked_Data" ) 
		                    "UNCHECKED DATA" 
		                ]
	                )
                >
            ]
            
            /* Drop all files and add new ones*/
            [
                IsPropertyModified( "Source_Files_Ref" )
                "\nDROP FILE ALL"
                [
                    "\nADD FILE FROM "
                    <
			            ForEachReference( "Source_Files_Ref" )
			            {
				            ListSeparator( ",\n" )
				            "'"
				            Property( "Name" )
				            "'"
			            }
			        >            
                ]    
            ]
        >
        
        FE::EndOfStatement
    ]

	/* Modify comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_updateextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "ASSEMBLY") 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Assembly comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Asymmetric_Key
	Execute( "Drop SQLServer_Asymmetric_Key" )
	Execute( "Create SQLServer_Asymmetric_Key" )
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Certificate
	[
		[
			Equal( Left( [ Execute( "Is Server Object" ) ], "2" ), "SO" )
			SetLocalFlag( "var_bServerObject" )
		]
		
		[ 
		    IsLocalFlagSet( "var_bServerObject" ) 
		    "EXEC ('USE master; \n" 
		]
	
		"ALTER CERTIFICATE " 
		< QuotedName >
		<
			[
				IsPropertyModified( "Is_Active_For_Begin_Dialog" )
				"\n\t" 
				"WITH ACTIVE FOR BEGIN_DIALOG = " 
				<
					LookupProperty( "Is_Active_For_Begin_Dialog", "true", "ON", "false", "OFF" )
				>
			]
			[
				IsPropertyModified( "Private_Key_File_Ref" )
				"\n" 
				"REMOVE PRIVATE KEY"
				[ 
				    IsLocalFlagSet( "var_bServerObject" ) 
				    ";\n')" 
				] /* close EXEC */
				
				FE::EndOfStatement
				
				[ 
				    IsLocalFlagSet( "var_bServerObject" ) 
				    "EXEC ('USE master; \n" 
				]
				
				"ALTER CERTIFICATE " 
				< QuotedName >
				[
					"\n" 
					"WITH PRIVATE KEY (FILE = '" 
					[
					    IsLocalFlagSet( "var_bServerObject" ) 
					    "'"
					]
					<
					    PushReference( "Private_Key_File_Ref" ) 
					        Property( "Name" ) 
					    Pop
					>
					[
					    IsLocalFlagSet( "var_bServerObject" ) 
					    "'"
					] 
					"')"
				]
			]
		>
		
		[ 
		    IsLocalFlagSet( "var_bServerObject" ) 
		    ";\n')" 
		] /* close EXEC */
		
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Credential
	[
		IsPropertyModified( "Identity" )
		"ALTER CREDENTIAL " 
		
		/* Specify the name of the credential. */
		< QuotedName >
		
		/* Specify the name of the account to be used when connecting outside the server.*/
		" WITH IDENTITY = " 
		"'"
		< Property( "Identity" ) >
		"'"
		
		FE::EndOfStatement
	]	
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Database
	[
		NotEqual( Property( "Database_Type" ), "Snapshot" )
		[
			IsPropertyModified( "Name" )
			"ALTER DATABASE "
			PushOldImage 
			    Property( "Name" ) 
			Pop
			"\n" 
			"MODIFY NAME = " 
			Property( "Name" )
			FE::EndOfStatement
		]
		
		[
			IsPropertyModified( "Logfiles_Ref" )
			"ALTER DATABASE " 
			< QuotedName >
			
			/* Remove all logfiles and add them again */
				
			"\n" 
			"REMOVE FILE " 
			"\n"
			FormatProperty( "Logfiles_Ref", "d:, ", "p:Name" )
	
			"\n" 
			"ADD LOG FILE " 
			"\n"
			<
				ForEachReference( "Logfiles_Ref" )
				{
					ListSeparator( "," )
					Execute( "Clause: Physical File Properties" )
				}
			>
			FE::EndOfStatement			
		]
			
		/* Specify the default collation for the database. */
		[ 
			IsPropertyModified( "Collation_Name" )
			"ALTER DATABASE " 
			< QuotedName > 
			"\n" 
			"COLLATE " 
			Property( "Collation_Name" )
			FE::EndOfStatement
		]	
			
		/* Change the attributes of the database. 
		   Since all database options do not use the WITH  clause or 
		   can be specified in combination with other options, 
		   they are grouped according to the syntax requirements.
		*/
		[
			"ALTER DATABASE " 
			< QuotedName >
			" SET "
			"\n\t"
			<
				Separator
				(
				    ", \n\t",
				    /* State Option */
				    [
				        IsPropertyModified( "State_Type" )
				        LookupProperty( "State_Type", "0", "ONLINE", "5", "EMERGENCY", "6", "OFFLINE" )
				    ],
    					
				    /* User access option */
				    [
				        IsPropertyModified( "Restricted_Access_Type" )
				        LookupProperty( "Restricted_Access_Type", "0", "MULTI_USER ", "1", "SINGLE_USER ", "2", "RESTRICTED_USER" )
				    ],
    		
				    /* Update Option */
				    [
					    IsPropertyModified( "Is_Read_Only" )
					    LookupProperty( "Is_Read_Only", "true", "READ_ONLY", "false", "READ_WRITE" )
				    ],
    					
				    /* Parameterization Option */
			        [
			            IsPropertyModified( "Parameterization" )
			            "PARAMETERIZATION " 
			            LookupProperty( "Parameterization", "0", "SIMPLE", "1", "FORCED" )
			        ],
    				    
			        /*Data Correlation Optimization option*/
			        [ 
			            IsPropertyModified( "Is_Data_Correlation_Optimization_Active" )
			            "DATE_CORRELATION_OPTIMIZATION " 
			            LookupProperty( "Is_Data_Correlation_Optimization_Active", "true", "ON", "false", "OFF" )
			        ]
			    )
			>
				
			/* Specify the termination option */
			[
				IsPropertyModified( "Termination_Option" )
				"\n WITH " 
				LookupProperty( "Termination_Option", "0", "ROLLBACK AFTER ", "1", "ROLLBACK IMMEDIATE", "2", "NO_WAIT" ) 
			    [
			        Equal( Property( "Termination_Option", "no_translate" ), "0" ) 
			        Property( "Termination_Wait_Time" )
			    ]
			]
			FE::EndOfStatement
		]
			
		[
			"ALTER DATABASE " 
			< QuotedName >
			" SET "
			"\n\t"
			<
				Separator
				(
				    ", \n\t", 
					/* Cursor Options */
					[
						IsPropertyModified( "Close_Cursor_On_Commit" )
						LookupProperty( "Close_Cursor_On_Commit", "true", "CURSOR_CLOSE_ON_COMMIT ON", "false", "CURSOR_CLOSE_ON_COMMIT OFF" )
					],
			
					/* Automatic Options */
					[
						IsPropertyModified( "Auto_Close" )
						LookupProperty( "Auto_Close", "true", "AUTO_CLOSE ON", "false", "AUTO_CLOSE OFF" )
					],
			
					[
						IsPropertyModified( "Auto_Create_Statistics" )
						LookupProperty( "Auto_Create_Statistics", "true", "AUTO_CREATE_STATISTICS ON", "false", "AUTO_CREATE_STATISTICS OFF" )
					],	
			
					[
						IsPropertyModified( "Auto_Shrink" )
						LookupProperty( "Auto_Shrink", "true", "AUTO_SHRINK ON", "false", "AUTO_SHRINK OFF" )
					],	
			
					[
						IsPropertyModified( "Auto_Update_Statistics" )
						LookupProperty( "Auto_Update_Statistics", "true", "AUTO_UPDATE_STATISTICS ON", "false", "AUTO_UPDATE_STATISTICS OFF" )
					],	
			
					[
						IsPropertyModified( "Auto_Update_Statistics_Async" )
						LookupProperty( "Auto_Update_Statistics_Async", "true", "AUTO_UPDATE_STATISTICS_ASYNC ON", "false", "AUTO_UPDATE_STATISTICS_ASYNC OFF" )
					],	
						
					/* SQL Options */
						
					[
						IsPropertyModified( "Is_Null_Default" )
						LookupProperty( "Is_Null_Default", "true", "ANSI_NULL_DEFAULT ON", "false", "ANSI_NULL_DEFAULT OFF" )
					],	
			
					[
						IsPropertyModified( "Use_Ansi_Nulls")
						LookupProperty( "Use_Ansi_Nulls", "true", "ANSI_NULLS ON", "false", "ANSI_NULLS OFF" )
					],	
						
					[
						IsPropertyModified( "Are_Strings_Padded" )
						LookupProperty( "Are_Strings_Padded", "true", "ANSI_PADDING ON", "false", "ANSI_PADDING OFF" )
					],	
						
					[
						IsPropertyModified( "Are_Warnings_Issued" )
						LookupProperty( "Are_Warnings_Issued", "true", "ANSI_WARNINGS ON", "false", "ANSI_WARNINGS OFF" )
					],	
							
					[
						IsPropertyModified( "Abort_On_Arithmetic_Error" )
						LookupProperty( "Abort_On_Arithmetic_Error", "true", "ARITHABORT ON", "false", "ARITHABORT OFF" )
					],	
							
					[
						IsPropertyModified( "Yield_Null_On_Null_Concatenation" )
						LookupProperty( "Yield_Null_On_Null_Concatenation", "true", "CONCAT_NULL_YIELDS_NULL ON", "false", "CONCAT_NULL_YIELDS_NULL OFF" )
					],	
							
					[
						IsPropertyModified( "Abort_On_Precision_Loss" )
						LookupProperty( "Abort_On_Precision_Loss", "true", "NUMERIC_ROUNDABORT ON", "false", "NUMERIC_ROUNDABORT OFF" )
					],	
							
					[
						IsPropertyModified( "Is_Quoted_Identifier" )
						LookupProperty( "Is_Quoted_Identifier", "true", "QUOTED_IDENTIFIER ON", "false", "QUOTED_IDENTIFIER OFF")
					],	
							
					[
						IsPropertyModified( "Allow_Recursive_Triggers" )
						LookupProperty( "Allow_Recursive_Triggers", "true", "RECURSIVE_TRIGGERS ON", "false", "RECURSIVE_TRIGGERS OFF")
					],	
							
					/* Recovery Options */
					[
						IsPropertyModified( "Recovery_Type" )
						[
						    "RECOVERY "  
						    LookupProperty( "Recovery_Type", "0", "FULL", "1", "BULK_LOGGED", "2", "SIMPLE" ) 
						]
					],	
							
					[
						IsPropertyModified( "Use_Torn_Page_Detection" )
						LookupProperty( "Use_Torn_Page_Detection", "true", "TORN_PAGE_DETECTION ON", "false", "TORN_PAGE_DETECTION OFF" )
					],	
							
					[
						IsPropertyModified( "Page_Verify" )
						[
						    "PAGE_VERIFY " 
						    LookupProperty( "Page_Verify", "0", "NONE", "1", "TORN_PAGE_DETECTION", "2", "CHECKSUM" ) 
						]
					]	
				)	
			>
			FE::EndOfStatement
		]
			
		/* Modify comments and UDP's as Extended Properties. */
		[ 
		    "\n" 
		    Execute( "Clause: Specify Database Extended Properties" ) 
		]
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Database_Role

	[  
		/* Handle name change*/
	   IsPropertyModified( "Name" )
	   FE::Bucket( "55" )
	   FE::RecordAlter
	   "ALTER ROLE "
		<
			[	
				PushOldImage 
				    Property( "Name" ) 
				Pop
				"\n" 
				"WITH NAME = " 
				Property( "Name" )
			]
		>
		FE::EndOfStatement
	]
	
    [
	    IsPropertyModified( "Authorization_Ref" )
	    "ALTER AUTHORIZATION ON ROLE::"
	    QuotedName
	    " TO "
	    <
	        PushReference( "Authorization_Ref" ) 
	            Property( "Name" ) 
	        Pop
	    > 
	    FE::EndOfStatement
    ]

	[   
	    /* Handle other changes */
	    FE::IsModified( "Name", "Authorization_Ref" )
	    Execute( "Generate SQLServer_Database_Role" )
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Filegroup
[
	"ALTER DATABASE	" 
	PushOwner 
	QuotedName
	Pop
	" MODIFY FILEGROUP "
	Execute("Previous Physical Name")
	/* Update Option */
	[
		IsPropertyModified(	"Is_Read_Write" )
		EnumProperty( "Read	Write"," READWRITE "," READONLY	" )
	]
	[
		IsPropertyModified(	"Is	Default" )
		[
			IsPropertyTrue(	"Is	Default" ) 
			"\n" 
			" DEFAULT "
		]				 
	]
	[
		IsPropertyModified(	"Name" )	
		[
			"\nNAME	= "	<QuotedName>
		]
	]
	FE::EndOfStatement	
]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Fulltext_Catalog
    [
        Set( "var_RequireDropRecreate", "false" )
	    [
	        @if ( IsPropertyModified( "Name" ) ) 
	        { 
	            Set( "var_RequireDropRecreate", "true" ) 
	        }
	        @if ( IsPropertyModified( "Authorization_Ref" ) ) 
	        { 
	            Set( "var_RequireDropRecreate", "true" ) 
	        }
	        @if ( IsPropertyModified( "File_Path")) 
	        { 
	            Set( "var_RequireDropRecreate", "true" ) 
	        }
	        @if ( IsPropertyModified( "SQLServer_Filegroup_Ref" ) ) 
	        { 
	            Set( "var_RequireDropRecreate", "true" ) 
	        }
	        Equal( Value( "var_RequireDropRecreate" ), "true" )
	        @if ( IsPropertyModified( "Name" ) )
	        {
	            /* use the old name when dropping the catalog */
		        FE::Option( "DropFulltextCatalog" )
		        "DROP  FULLTEXT CATALOG "
		        [
		            FE::Option( "QuoteName" )     
		            "\""
		        ]
		        /*OldPropertyValueX( "Name" ) */
		        [
		            PushOldImage
		                Property( "Name" )
		            Pop
		        ] 
		        [
		            FE::Option( "QuoteName" ) 
		            "\""
		        ]
		        FE::EndOfStatement
	        }
	        @else
	        {
	            Execute( "Drop SQLServer_Fulltext_Catalog" )
	        }
	        Execute( "Create SQLServer_Fulltext_Catalog" )
	    ]
	    [
	        Equal( Value( "var_RequireDropRecreate" ), "false" )
		    [
				[
					"ALTER FULLTEXT CATALOG "
		    		< QuotedName >
					<
			    		[
			        		"\n" 
			        		"REBUILD "
				    		IsPropertyModified( "Is_Accent_Sensitive" )
				    		"WITH ACCENT_SENSITIVITY = "
				    		LookupProperty( "Is_Accent_Sensitive", "true", "ON", "false", "OFF" )
			    		]
					>
					FE::EndOfStatement
				]
				[
					"ALTER FULLTEXT CATALOG "
		    		< QuotedName >
					<
						[
				    		IsPropertyModified( "Is_Default" )
				    		[
				        		IsPropertyTrue( "Is_Default" ) 
				        		"\n" 
				        		"AS DEFAULT"
				    		]      
			    		]
		    		>
					FE::EndOfStatement
				]
			]
	    ]
        Remove( "var_RequireDropRecreate" )
    ]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Fulltext_Index
	[
		Set( "var_AlterStatement", "\nALTER FULLTEXT INDEX ON " <PushOwner("Entity_Ref" ) QuotedName Pop> "\n" )
		<
			[
				IsPropertyModified( "Is_Disabled" )
				Value( "var_AlterStatement" )
				LookupProperty( "Is_Disabled", "true", "DISABLE", "false", "ENABLE")
				FE::EndOfStatement
			]
			[
				IsPropertyModified( "Change_Tracking_Type" )
				/* Specify the details regarding change tracking. */
				@if(Equal(Property("Change_Tracking_Type"),"Off No Population"))
				{ 
					Execute("Drop SQLServer_Fulltext_Index")
					Execute("Create SQLServer_Fulltext_Index")
				}
				@else
				{
					Value( "var_AlterStatement" )
					"SET CHANGE_TRACKING "
					LookupProperty( "Change_Tracking_Type", "0", "MANUAL", "1", "AUTO", "2", "OFF","AUTO")
					FE::EndOfStatement
				}
			]
			[
				IsPropertyModified( "Population_Mode" )
				Value( "var_AlterStatement" )
				LookupProperty( "Population_Mode", "0", "START FULL POPULATION", "1", "START INCREMENTAL POPULATION", "2", 
					            "START UPDATE POPULATION", "3", "STOP POPULATION", "STOP POPULATION" )
				FE::EndOfStatement
			]
		>
		Remove( "var_AlterStatement" )
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Fulltext_Index_Column
	Execute( "Drop SQLServer_Fulltext_Index_Column" )
	Execute( "Create SQLServer_Fulltext_Index_Column" )
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Login
[
	ShouldGenerate
	FE::Bucket("55")
	[
		IsPropertyModified( "Name" )
		"ALTER LOGIN " 
		PushOldImage 
		    QuotedName 
		Pop
		"\nWITH " 
		"NAME = " 
		QuotedName
		FE::EndOfStatement
	]
	Set( "var_AlterStatement", "ALTER LOGIN " QuotedName )
	[
		IsPropertyModified( "Is_Disabled" )
		Value( "var_AlterStatement" )
		"\n" 
		LookupProperty( "Is_Disabled", "true", "DISABLE", "false", "ENABLE" )
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "SQLServer_Database_Ref" ) 
		Value( "var_AlterStatement" )
		"\nWITH " 
		"DEFAULT_DATABASE = " 
		<
		    PushReference( "SQLServer_Database_Ref" ) 
		        Property( "Name" ) 
		    Pop
		> 
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "Language" )
		Value( "var_AlterStatement" )
		"\nWITH " 
		"DEFAULT_LANGUAGE = " 
		< Property( "Language" ) >
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "Check_Expiration" ) 
		Value( "var_AlterStatement" )
		"\nWITH " 
		"CHECK_EXPIRATION = " 
		LookupProperty( "Check_Expiration", "true", "ON", "false", "OFF" )
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "Check_Policy")
		Value( "var_AlterStatement" )
		"\nWITH " 
		"CHECK_POLICY = " 
		LookupProperty( "Check_Policy", "true", "ON", "false", "OFF" )
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "Credential_Ref" )
		Value( "var_AlterStatement" )
		"\nWITH " 
		"CREDENTIAL = " 
		<
		    PushReference( "Credential_Ref" ) 
		        Property( "Name" ) 
		    Pop
		>
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "Unlock_Password" )
		Value( "var_AlterStatement" )
		"\nWITH " 
		"PASSWORD = '" 
		FE::Password 
		"'"
		<
		    IsPropertyTrue( "Unlock_Password" ) 
		    "\n" 
		    "UNLOCK" 
		>
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "Password_Must_Change_On_Next_Logon" )
		Value( "var_AlterStatement" )
		"\nWITH " 
		"PASSWORD = '" 
		FE::Password 
		"'"
		<
		    IsPropertyTrue( "Password_Must_Change_On_Next_Logon" ) 
		    "\n" 
		    "MUST_CHANGE" 
		>
		FE::EndOfStatement
	]
	Remove( "var_AlterStatement" )
]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Partition_Function
[
	[ 
		IsPropertyModified( "Partition_Values" )
		[ 
			ForEachPropertyValue( "Partition_Values", "old_only" )
			{
				FE::Bucket( "76" )
				"ALTER PARTITION FUNCTION " Property( "Name" ) "() "
				"\nMERGE RANGE (" ForEachPropertyValue.Value ")"
				FE::EndOfStatement
			}
		]
		[
			ForEachPropertyValue( "Partition_Values", "new_only" )
			{
				FE::Bucket( "76" )
				"ALTER PARTITION FUNCTION " Property( "Name" ) "() "
				"\nSPLIT RANGE (" ForEachPropertyValue.Value ")"
				FE::EndOfStatement
			}		
		]
	]
	[
		IsModified("Partition_Values" )
		Execute("Generate SQLServer_Partition_Function")
	]
	/* Modify comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_updateextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "PARTITION FUNCTION" ) 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Partition Function comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]

	/* TODO: other property changes need to be handled here... */
	
]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Partition_Scheme
	[
		"ALTER PARTITION SCHEME " 
		<
		    Property( "Physical_Name" ) 
		    "()"
		>
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Physical_File
[
	"ALTER DATABASE " 
	PushOwner 
	PushOwner
	< QuotedName > 
	Pop 
	Pop
		
	"\n" 
	"MODIFY FILE "
	"\n\t( " 
	"NAME = " Execute("Previous Name")
	[
		IsPropertyModified("Name")
		",\n\t"
		"NEWNAME = " Property( "Name" ) 
	]
	[
		IsPropertyModified("File_Name")
		",\n\t"
		"FILENAME = " Property( "File_Name" ) 
	]
	[
		IsPropertyModified("File_Size")
		",\n\t"
		"Size = " Property("File_Size")
	]
	[
		IsPropertyModified("Max_Size")
		",\n\t"
		"MAXSIZE = " < Property( "Max_Size" ) >
	]
	[
		IsPropertyModified("File_Growth_Size")
		",\n\t"
		"FILEGROWTH = " < Property( "File_Growth_Size" ) >
		[
						  Equal( Property( "File_Growth_By_Type" ), "Percent" )
						  "%"
					 ]
	]
	[
		 /* State Option */
		IsPropertyModified( "State_Type" )
		",\n\t"
		LookupProperty( "State_Type", "0", "ONLINE", "1", "OFFLINE" )
	]
	")"
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_Symmetric_Key
	Execute( "Drop SQLServer_Symmetric_Key" )
	Execute( "Create SQLServer_Symmetric_Key" )
SPItemEnd

SPItemBegin [keep format] = Alter SQLServer_XML_Schema_Collection
	/* Modify comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_updateextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" )
		[ 
		    PushReference( "Schema_Ref" ) 
		        Set( "var_Level0Name", Property( "Name" ) ) 
		    Pop 
		]
		Set( "var_Level1Type", "XML SCHEMA COLLECTION" ) 
		Set( "var_Level1Name", Property( "Name" ) )
		
		/* Generate XML Schema Collection comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
	Execute( "Drop SQLServer_XML_Schema_Collection" )
	Execute( "Create SQLServer_XML_Schema_Collection" )
SPItemEnd

SPItemBegin [keep format] = Alter Schema
	[
		IsPropertyModified( "Owner_Ref" )
		Set( "var_SchemaName", QuotedName )
		"ALTER AUTHORIZATION ON SCHEMA :: "
		< Value( "var_SchemaName" ) >
		" TO "
        PushReference( "Owner_Ref" )
			    QuotedName
		Pop
		FE::EndOfStatement
		Remove( "var_SchemaName" )
	]
	/* Modify comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_updateextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" ) 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Schema comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
SPItemEnd

SPItemBegin [keep format] = Alter Stored_Procedure
[
	Equal( ObjectType, "Stored_Procedure" )
	@if ( IsPropertyModified( "Physical_Name" ) )
	{	     
	    Execute( "Alter Object Physical Name" )
	}
	@else
	{
	    Execute( "Generate Stored_Procedure" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Table Check Constraint Usage
[
    /* -moved from Generic Alter- */
	PushOwner
		Equal( ObjectType, "Entity" ) 
	Pop 

    ShouldGenerate
    [
        /* Generate alter for disabled SQL 92 constraints. */
        IsPropertyModified( "Is_Disabled" )
        FE::Bucket( "94" )
        FE::RecordAlter
        
        /* Set Table as context. */
        PushOwner  
        [
            "ALTER TABLE " 
            /* Name of the Table.*/
            [ FE::OwnerOverride( "true" ) "." ]
            < QuotedName >
        ]
        Pop
        
        /* Emit nocheck/check clause. */
        " "
        [ LookupProperty( "Is_Disabled", "true", "NO" ) ]
        "CHECK"
        /* Emit constraint name. */
        " CONSTRAINT " 
        < QuotedName >				
        [FE::EndOfStatement]
    ]
    
    [
        @if ( IsModified( "Is_Disabled" ) )
        {
            Execute( "Generate Table Check Constraint Usage" )
        }
    ]
]    
SPItemEnd

SPItemBegin [keep format] = Alter Trigger
[
	Equal( ObjectType, "Trigger" )
	[
		IsPropertyModified( "Physical_Name" )
		Execute( "Alter Object Physical Name" )
	]

	/* Ignore Schema_Ref changes for triggers.				  */
	/* The triggers are moved when the parent table is moved. */

	[
		@if ( IsModified( "Physical_Name", "Schema_Ref" ) )
		{
		    Execute( "Generate Trigger" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter User_Id
[
	[
		IsPropertyModified( "Name" )
		PushOldImage
		    "ALTER USER " 
		    Property( "Name" )
		Pop
		"\n" 
		"WITH NAME = " 
		Property( "Name" )
		FE::EndOfStatement
	]
	[
		IsPropertyModified( "SQLServer_Schema_Ref" )
		"ALTER USER " 
		Property( "Name" )
		"\n" 
		"WITH DEFAULT_SCHEMA = "
		PushReference( "SQLServer_Schema_Ref" ) 
		Property( "Name" ) 
		Pop
		FE::EndOfStatement
	]
	[
		@ifnot(IsPropertyModified("Name","SQLServer_Schema_Ref"))
		{
			Execute("Generate User_Id")
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Validation_Rule
[
	Equal( ObjectType, "Validation_Rule" )
	@if ( IsPropertyTrue( "Generate_As_SQL_92_Format" ) )
	{
		/*Modify properties if the Validation rule uses SQL 92 format*/
		[ Execute( "Generate Validation_Rule" ) ]
	}
	@elseif ( IsPropertyModified( "Physical_Name" ) )
    {
	    /*Rename if the Validation rule uses sp_bindrule*/
	    [ Execute( "Alter Object Physical Name" ) ]
    }
    @else
    {
        /*Modify properties if the Validation rule uses sp_bindrule*/
	    [ Execute( "Generate Validation_Rule" ) ]
    }
]
SPItemEnd

SPItemBegin [keep format] = Alter View
[
	Equal( ObjectType, "View" )
	/* Process the Physical Name (EMXTypes::pPhysicalNameX)	property of the View. */
	[
	    IsPropertyModified( "Name" ) 
	    Execute( "Alter Object Physical Name" )
	]

	[
		IsPropertyModified( "Schema_Ref" )
		FE::Bucket( "28" )
		FE::RecordAlter 
		"ALTER SCHEMA " 
		PushReference( "Schema_Ref" ) 
		    QuotedName 
		Pop
		"\n" 
		"TRANSFER " 
		PushOldImage
		    PushReference( "Schema_Ref" ) 
		        [ QuotedName ]
		    Pop
		Pop 
		"."
		QuotedName
		FE::EndOfStatement
	]

	[
		@if ( IsModified( "Name", "Schema_Ref" ) )
		{
		    Execute( "Generate View" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: AKConstraint
[
    IsPropertyTrue( "Generate_As_Constraint" )
	Equal( Left( Property( "Key_Group_Type" ), 2), "AK" )
	OnceForObject( "Constraint")
	[
        FE::Option( "ConstraintName" )
        [
            "CONSTRAINT " 
			[ FE::Option( "QuoteName" )"\"" ]
            Property( "Constraint_Name" )
			[ FE::Option( "QuoteName" )"\"" ]
        ]
	]
	" UNIQUE " 
	[
	    "  " 
	    FE::Option( "IndexClustered" ) 
	    LookupProperty( "Is_Clustered", "true", "CLUSTERED" )	
	    " "
	]
	"("
	ForEachReference( "Index_Members_Order_Ref", "require_one" )
	{
		ListSeparator(  ",")
		QuotedName
		[
		    "  " 
		    Property( "Key_Group_Sort_Order", "no_translate" )
		]
	}
	")"
	[
		FE::Option( "IndexPhysicalStorage" )
		
		/* Specify the fill factor and the index options.*/
		[
			"\n\t"	
			"WITH "
			"\n\t("
			"\n\t\t"
			<
				Separator
				(
				    ",\n\t\t",
					["PAD_INDEX = "					LookupProperty( "SQLServer_Pad_Index",         "true", "ON", "false", "OFF" )],
					["FILLFACTOR = " 				< Property( "SQLServer_Fill_Factor" ) >                                      ],
					["IGNORE_DUP_KEY = "			LookupProperty( "SQLServer_Ignore_Duplicate_Keys",   "true", "ON", "false", "OFF" )],
					["STATISTICS_NORECOMPUTE = "	LookupProperty( "SQLServer_Keep_Existing_Statistics",      "true", "ON", "false", "OFF" )],
					["ALLOW_ROW_LOCKS = "			LookupProperty( "Allow_Row_Locks",              "true", "ON", "false", "OFF" )],
					["ALLOW_PAGE_LOCKS = "			LookupProperty( "Allow_Page_Locks",             "true", "ON", "false", "OFF" )],
					
					["SORT_IN_TEMPDB = "			LookupProperty( "SQLServer_Sort_In_Temp_DB",              "true", "ON", "false", "OFF" )],
					["ONLINE = "	        		LookupProperty( "Online",                       "true", "ON", "false", "OFF" )],
					["MAXDOP = "			        < Property( "SQLServer_Max_Parallel" ) >                                      ]  
					
				)
			>
			"\n\t)"
		]

		/*Specify the partition scheme or filegroup on which the table is stored.*/
		[
			"\n\t"	
			" ON " 
			<
				[
					PushReference( "SQLServer_Partition_Scheme_Ref" ) 
					    < Property( "Name" ) > 
					Pop
					"( "
					ForEachReference( "Partition_Columns_Ref" )
					{
						ListSeparator(  ",")
						< Property( "Physical_Name" ) >
					}
					" )"
				]
				[
				    PushReference( "SQLServer_File_Group_Ref" ) 
				        "\"" 
				        < Property( "Name" ) > 
				        "\"" 
				    Pop
				]
			>
		]	
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: AttributeDatatype
[ 
    
    @if ( IsPropertyNull( "Expression" ) )
    {
        /* Check for an underlying UDD if any */
        Set( "var_bUseDatatype", "true" )
        [
	        PushReference( "Parent_Domain_Ref" )
	        [
		        @if(Equal(Property( "Generate_As_User_Defined_Type" ),"true"))
		        {
		        	[
						PushReference( "Schema_Ref" )
							[ Property( "Name" ) "." ]
		        		Pop
					]
	        		@if(FE::Option("ColumnUseDomain"))
					{
					    Set("GenerateAsUDD","true")
						QuotedName
						Set( "var_bUseDatatype", "false" )
					}
					@else
					{
						< Property( "Physical_Data_Type" ) >
						Set( "var_bUseDatatype", "false" )
					}
				}
	        ]
	        Pop
        ]
        @if ( Equal( Value( "var_bUseDatatype" ), "true" ) )
        {
	        < Property( "Physical_Data_Type" ) >
        }
        Remove( "var_bUseDatatype" )
    }
    @else
    {
        "AS " 
        Property( "Expression" )
    }
]
SPItemEnd

SPItemBegin [keep format] = Clause: CLR Function Return Table
    [
        "( "
        
        ForEachReference( "Physical_Columns_Order_Ref" )
        {
            Set("GenerateAsUDD","false")
	        ListSeparator(  ",")
	        "\n\t" 
        	
	        /* Name of the column */
	        QuotedName 
	        " "
	        /* Specify the datatype. */
            Execute( "Clause: AttributeDatatype" )        	
	        " "
	        /* Specify the xml schema collection if the datatype is an xml type. */
	        [
		        IsPropertyNull( "Expression" )
		        Equal( Property( "Physical_Data_Type" ), "xml" )
		        "( "
        		
		        [ 
		            UpperCase( Property( "SQLServer_XML_Document_Type" ) ) 
		            " " 
		        ]
        		
		        <
			        PushReference( "SQLServer_XML_Schema_Collection_Ref" )
			        [
				        PushReference( "Schema_Ref" ) 
				        [
					        Property( "Name" ) 
					        "."
				        ] 
				        Pop
				    ]
			        QuotedName
			        Pop
		        >
		        " )"
	        ]
        	
	         /* Specify the collation for the column if the underlying datatype is not User Defined.*/
	        [
	            Equal(Value("GenerateAsUDD"),"false")
				Set( "var_sDatatype", Property("Physical_Data_Type") )
				Set( "var_bSuceed", "false" )
				@if( Equal( Left( Value("var_sDatatype"), "4"), "char") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "7"), "varchar") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "4"), "text") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "5"), "nchar") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "8"), "nvarchar") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "5"), "ntext") )
				{
					Set( "var_bSuceed", "true" )
				}
					
				[
					Equal( Value("var_bSuceed"), "true" )
					"COLLATE " <Property("Collation_Name")> " "
				]
				
				Remove( "var_sDatatype" )
				Remove( "var_bSuceed" )
	        ]

			
			Remove("GenerateAsUDD")

        	
	        /* Check if the computed column is persisted. */
	        @if ( IsPropertyTrue( "SQLServer_Is_Persisted" ) )
	        {
	            "PERSISTED "
	            LookupProperty( "Null_Option_Type","1","NOT NULL","" )
	            " "
	        }
	        @else
	        {
		        /* Specify if null values are allowed in the column.*/
		        IsPropertyNull("Expression" ) 
		        " " 
	        }
        }
        
        "\n" 
        ")"
    ]
SPItemEnd

SPItemBegin [keep format] = Clause: FKConstraint
[
	Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" )
	PushReference( "Relationship_Ref" )
	[
		ShouldGenerate
		PushReference( "Child_Entity_Ref" )
		[
			ShouldGenerate
			Set( "var_Proceed", "true" )
		]
		Pop
		
		PushReference( "Parent_Entity_Ref" )
		[
			@if ( FE::FilterDanglingRelationships )
			{
				Set( "var_Proceed", "false" )
			}
			@else
			{
				Set( "var_Proceed", "true" )
			}
		]
		Pop
	]
	Pop

	[	
		FE::IsAlterScriptGeneration
		Equal( "var_Proceed", "false" )
		/*Generate if the object referenced by the deleted object has also been deleted.*/
		/*If the object referenced by the deleted object is still active, then check the Generate property on the referenced object*/

		IsDeleted
		[
		    @if ( IsPropertyModified( "Relationship_Ref" ) )
		    {
		    PushOldImage
		    
			/* The relationship referenced by the KeyGroup has been deleted*/
			/*FK indexes are maintained as long as the relationship is active*/
			[
				IsDeleted
				[
				    @if ( IsPropertyModified( "Child_Entity_Ref" ) )
				    {
				    PushOldImage
					[
						/* The Child Entity referenced by the deleted relationship has also been deleted*/
						@if ( IsDeleted )
						{
						    Set( "var_Proceed", "true" )
						}
						@else
						{
						    "Not Deleted"
						    ShouldGenerate
						    Set( "var_Proceed", "true" )
						}
					]
					Pop
					}
				]
				Pop
			]
			Pop
			}
		]
		Pop
	]

	[	
		Equal( Value( "var_Proceed" ), "true" )
		OnceForObject( "Constraint" )
		[	
			FE::Option( "ConstraintName" )
			
			/*IsNullX([Execute("Suppress Constraint Name")])*/
			Equal( Execute( "Suppress Constraint Name" ), "" )
		    [
                [
                    "CONSTRAINT " 
					[ FE::Option( "QuoteName" )"\"" ]
                    Property( "Constraint_Name", "fail_if_empty" )
					[ FE::Option( "QuoteName" )"\"" ]
                ]
		    ]
		]
		" FOREIGN KEY "
		"("
		<
		    ForEachFKColumn 
		    {
			    ListSeparator( "," )
			    < QuotedName >
		    }
		>
		")"
		" REFERENCES "
		[
			PushReference( "Relationship_Ref" )
			[
				PushReference( "Parent_Entity_Ref" )
				[
					Equal( ObjectType, "Entity" )
					[ FE::OwnerOverride( "true" ) "." ] 
					QuotedName
				]
				[
					Equal( ObjectType, "Subtype_Symbol" )
				    ForEachReference( "Child_Relationships_Ref", "require_one" )
				    {
					    PushReference( "Parent_Entity_Ref" )
					        [ FE::OwnerOverride( "true" ) "." ] 
					        QuotedName
					    Pop
				    }
				]
			    Pop
			]
		    Pop
		]

		"("
		<
			ForEachMigratingColumn 
			{
				ListSeparator( "," )
				< QuotedName >
			}
		>
		")"


		[
			PushReference( "Relationship_Ref" )
			[
				FE::Option( "OnDeleteFKConstraint" )
				Set( "var_Rule", Property( "Parent_Delete_Rule" ) )
				"\n\t\t" 
				"ON DELETE " 
				<
					@ifnot ( IsMatch( Value( "var_Rule" ), "Restrict", "None" ) )
					{ 
					    UpperCase( Value( "var_Rule" ) ) 
					}
				>
				Remove( "var_Rule" )
			]
			
			[
				FE::Option( "OnUpdateFKConstraint" )
				Set( "var_Rule", Property( "Parent_Update_Rule" ) )
				"\n\t\t" 
				"ON UPDATE " 
				<
					@ifnot ( IsMatch( Value( "var_Rule" ), "Restrict", "None" ) )
					{ 
					    UpperCase( Value( "var_Rule" ) ) 
					}
				>
				Remove( "var_Rule" )
			]
				
			[IsPropertyTrue("Is Not For Replication") "\r\n\t\t" "NOT FOR REPLICATION "]

			Pop
			
		]
	]
	Remove( "var_Proceed" )
]
SPItemEnd

SPItemBegin [keep format] = Clause: Function Options
	"\n"
	"WITH "
	Separator
	(
	    ",\n\t",
		[
		    IsPropertyTrue( "SQLServer_Is_Obfuscated" ) 
		    "ENCRYPTION" 
		],
		[
		    IsPropertyTrue( "SQLServer_Use_Schema_Binding" ) 
		    "SCHEMABINDING"
		],
		[ LookupProperty( "SQLServer_Null_Input_Mode", "0", "CALLED ON NULL INPUT", "1", "RETURNS NULL ON NULL INPUT" ) ],
		[
			"EXECUTE AS "
			Switch( Property( "SQLServer_Execute_As_Mode" ) )
			{
				Choose( "Execute As Caller" )
				{
				    "CALLER"
				}
				Choose( "Execute As Self" )
				{
				    "SELF"
				}
				Choose( "Execute As Owner" )
				{
				    "OWNER"
				}
				Choose( "Execute As User" )
				{
					PushReference( "User_Id_Ref" ) 
					    Property( "Name" ) 
					Pop
				}
			}
		]
    )
SPItemEnd

SPItemBegin [keep format] = Clause: Function Statements
	
	/* Name of the function. */
	[ FE::OwnerOverride( "true" ) "." ]
	< QuotedName >	
	
	/* Parameters */
	" ("
	[
		ForEachOwnee("Parameter" )
		{
			ListSeparator(  ",")
			< Property( "Name" ) >
			" AS "
			[ FE::OwnerOverride( "true" ) "." ]
			< Property( "Physical_Data_Type" ) >
			[
			    " = " 
			    < Property( "Default_Value" ) >
			]
		}
	]
	")"
	
	/* Return Type */
	"\nRETURNS "
	Set( "var_FunctionType", Property( "SQLServer_Function_Type" ) )
	<
		Switch( Value( "var_FunctionType" ) )
		{
			Choose( "Scalar Function" )
			{
				< Property( "SQLServer_Return_Data_Type" ) >
				
				/* Function Options */
				Execute( "Clause: Function Options" )
				
				/* Function Body */
				"\n" 
				"AS"
				"\n" 
				"BEGIN"
				"\n\t"
                FE::ExpandERwinMacro( "Template_Code" )
	
				/* Return Variable*/
				"\n\t" 
				"RETURN "
				/*< Property( "SQLServer_Return_Variable" )>*/ /*--*/
				"\n" 
				"END"
			}
			Choose( "InlineTable" )
			{
				"TABLE"
				
				/* Function Options */
				Execute( "Clause: Function Options" )
							
				/* Return Variable*/
				"\n" 
				"AS"
				"\n" 
				"RETURN "
				PushReference( "Return_Table_Definition_Ref" )
				    [ Execute( "Create Entity" ) ]
				Pop
			}
			Choose( "MultistatementTable" )
			{
				< Property( "SQLServer_Return_Variable" ) >
				" TABLE "
				PushReference( "Return_Table_Definition_Ref" )
				    [ Execute( "Create Entity" ) ]
				Pop
				"\n"
				
				/* Function Options */
				Execute( "Clause: Function Options" )
				
				/* Function Body */
				"\n" 
				"AS"
				"\n" 
				"BEGIN"
				"\n\t"
                FE::ExpandERwinMacro( "Template_Code" )
	
				/* Return Variable*/
				"\n\t" 
				"RETURN "
				"\n" 
				"END"			
			}
			Choose( "Assembly" )
			{
				<
					[ Property( "SQLServer_Return_Data_Type" ) ]
					[
						"TABLE "
						<
							PushReference( "Return_Table_Definition_Ref" )
							    [ Execute( "Create Entity" ) ]
							Pop
						>
					]
				>
				
				/* CLR Function Options */
				"\n"
				"WITH "
				Separator
				(
				    ",\n\t",
					[ LookupProperty( "SQLServer_Null_Input_Mode", "0", "CALLED ON NULL INPUT", "1", "RETURNS NULL ON NULL INPUT" ) ],
					[
						"EXECUTE AS "
						Switch( Property( "SQLServer_Execute_As_Mode" ) )
						{
							Choose( "Execute As Caller" )
							{
							    "CALLER"
							}
							Choose( "Execute As Self" )
							{
							    "SELF"
							}
							Choose( "Execute As Owner" )
							{
							    "OWNER"
							}
							Choose( "Execute As User" )
							{
								PushReference( "User_Id_Ref" ) 
								    Property( "Name" ) 
								Pop
							}
						}
					]
				)
				
				/* Return Type */
				"\n" 
				"AS EXTERNAL NAME "
				PushReference( "SQLServer_Assembly_Ref" ) 
				    Property( "Name" ) 
				    "." 
				Pop
				Property( "SQLServer_Class_Name" )
				"."
				Property( "SQLServer_Method_Name" )
			}
		}
	>
	Remove( "var_FunctionType" )
SPItemEnd

SPItemBegin [keep format] = Clause: PKConstraint
	[
        IsPropertyTrue( "Generate_As_Constraint" )
		Equal( Left( Property( "Key_Group_Type" ), 2 ), "PK" )
		OnceForObject( "Constraint" )
		FE::RecordCreate
		[				
            FE::Option( "ConstraintName" )
            [
                "CONSTRAINT " 
				[ FE::Option( "QuoteName" ) "\"" ]
                Property( "Constraint_Name" )
            	[ FE::Option( "QuoteName" ) "\"" ]
			]
		]
		" PRIMARY KEY "	
		[
		    " " 
		    FE::Option( "IndexClustered" ) 
		    LookupProperty( "Is_Clustered", "true", "CLUSTERED", "NONCLUSTERED" ) 
		    " "
		]
		"("
	    ForEachReference( "Index_Members_Order_Ref", "require_one" )
	    {
		    ListSeparator( "," )
		    QuotedName
		    [
		        " " 
		        Property( "Key_Group_Sort_Order", "no_translate" )
		    ]
	    }
		")"
	
		[
			FE::Option( "IndexPhysicalStorage" )
			
			/* Specify the fill factor and the index options.*/
			[
				"\n\t" 
				"WITH"
				"\n\t" 
				"("
				"\n\t\t"
				<
					Separator
					(
					    ",\n\t\t",
						["PAD_INDEX = "					LookupProperty( "SQLServer_Pad_Index", "true", "ON", "false", "OFF" )],
						["FILLFACTOR = "				< Property( "SQLServer_Fill_Factor" ) >],
						["IGNORE_DUP_KEY = "			LookupProperty( "SQLServer_Ignore_Duplicate_Keys", "true", "ON", "false", "OFF" )],
						["STATISTICS_NORECOMPUTE = "	LookupProperty( "SQLServer_Keep_Existing_Statistics", "true", "ON", "false", "OFF" )],
						["ALLOW_ROW_LOCKS = "			LookupProperty( "Allow_Row_Locks", "true", "ON", "false", "OFF" )],
						["ALLOW_PAGE_LOCKS = "			LookupProperty( "Allow_Page_Locks", "true", "ON", "false", "OFF" )],

					    [ "SORT_IN_TEMPDB = "			LookupProperty( "SQLServer_Sort_In_Temp_DB",    "true", "ON", "false", "OFF" ) ],
					    [ "ONLINE = "	        		LookupProperty( "Online",                       "true", "ON", "false", "OFF" ) ],
					    [ "MAXDOP = "			        < Property( "SQLServer_Max_Parallel" ) >                                       ]  
					)
				>
				"\n\t"	
				")"
			]
	
			/*Specify the partition scheme or filegroup on which the table is stored.*/
			[
				"\n\t" 
				" ON " 
				<
					[
						PushReference( "SQLServer_Partition_Scheme_Ref" ) 
						    < Property( "Name" ) > 
						Pop
						"( "
						ForEachReference( "Partition_Columns_Ref" )
						{
							ListSeparator( "," )
							< Property( "Physical_Name" ) >
						}
						" )"
					]
					[
					    PushReference( "SQLServer_File_Group_Ref" ) 
					        "\"" 
					        < Property( "Name" ) > 
					        "\"" 
					    Pop
					]
				>
			]	
		]
	]
SPItemEnd

SPItemBegin [keep format] = Clause: Physical File Properties

    "( \n\t"
    "NAME = '" 
    Property( "Name" ) 
    "'"
    ", \n\t" 
    "FILENAME = '" 
    Property( "File_Name" ) 
    "'"
    [
        ", \n\t" 
        "SIZE = " 
        < Property( "File_Size" ) >
    ]
    [
        ", \n\t" 
        "MAXSIZE = " 
        < Property( "Max_Size" ) >
    ]
    [
	    ", \n\t" 
	    "FILEGROWTH = " 
	    < Property( "File_Growth_Size" ) >
	    [
	        Equal( Property( "File_Growth_By_Type" ), "Percent" ) 
	        "%"
	    ]
    ]
    "\n) "

SPItemEnd

SPItemBegin [keep format] = Clause: Regular Function Return Table
    [
        "( "
        
        ForEachReference( "Physical_Columns_Order_Ref" )
        {
            Set("GenerateAsUDD","false")
	        ListSeparator(  ",")
	        "\n\t" 
        	
	        /* Name of the column */
	        QuotedName 
	        " "
        	
	        /* Specify the datatype. */
	        /* Replacement of the old macro DatatypeX */
        	/*Execute( "Clause: AttributeDatatype" )*/
        	
	        @if( IsPropertyNull("Expression") )
	        {
                
		        /* Check for an underlying UDD if any */
		        Set("var_bProceed", "true")
		        
		        [
			        PushReference("Parent_Domain_Ref")
			        [
				        IsPropertyTrue("Generate_As_User_Defined_Type")
				        [
					        PushReference("Schema_Ref")
					        [Property("Name") "."]
					        Pop
				        ]
				        Set("GenerateAsUDD","true")
				        QuotedName
				        Set("var_bProceed", "false")
			        ]
			        Pop
		        ]
		        
		        [
			        Equal( Value("var_bProceed"), "true" )
			        <Property("Physical_Data_Type")>
		        ]
		        
		        Remove( "var_bProceed" )
		        
		        
	        }
	        @else
	        {
		        "AS " Property("Expression")
	        }
            


        	
	        " "
	        /* Specify the xml schema collection if the datatype is an xml type. */
	        [
		        IsPropertyNull( "Expression" )
		        Equal( Property( "Physical_Data_Type" ), "xml" )
		        "( "
        		
		        [ UpperCase( Property( "SQLServer_XML_Document_Type" ) ) " " ]
        		
		        <
			        PushReference( "SQLServer_XML_Schema_Collection_Ref" )
			        [
				        PushReference( "Schema_Ref" ) 
				        [
					        Property( "Name" ) 
					        "."
				        ] 
				        Pop
				    ]
			        QuotedName
			        Pop
		        >
		        " )"
	        ]
        	
	         /* Specify the collation for the column if the underlying datatype is not User Defined.*/
	        [
	            Equal(Value("GenerateAsUDD"),"false")
				Set( "var_sDatatype", Property("Physical_Data_Type") )
				Set( "var_bSuceed", "false" )
				@if( Equal( Left( Value("var_sDatatype"), "4"), "char") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "7"), "varchar") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "4"), "text") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "5"), "nchar") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "8"), "nvarchar") )
				{
					Set( "var_bSuceed", "true" )
				}
				
				@if( Equal( Left( Value("var_sDatatype"), "5"), "ntext") )
				{
					Set( "var_bSuceed", "true" )
				}
					
				[
					Equal( Value("var_bSuceed"), "true" )
					"COLLATE " <Property("Collation_Name")> " "
				]
				
				Remove( "var_sDatatype" )
				Remove( "var_bSuceed" )
	        ]

			
			Remove("GenerateAsUDD")
        	
	        /* Check if the computed column is persisted. */
	        @if ( IsPropertyTrue( "SQLServer_Is_Persisted" ) )
	        {
		        "PERSISTED "
		        LookupProperty( "Null_Option_Type","1","NOT NULL","" )
		        " "
	        }
	        @else
	        {
		        /* Specify if null values are allowed in the column.*/
		        IsPropertyNull("Expression" ) 
		        " " 
		        LookupProperty( "Null_Option_Type","0","NULL","1","NOT NULL")	
		        " " 
	        }

	        /*SQL Server does not allow Identity to be inherited from its UDD*/
	        [ 
		        [ 
		            LookupProperty( "Null_Option_Type", "8", "IDENTITY" ) 
		            " " 
		        ] 
		        [
		            "(" 
		            < Property( "Identity_Seed" ) > 
		            ")" 
		            " "
		        ]
		        [
		            IsPropertyTrue( "Is_Not_For_Replication" ) 
		            "NOT FOR REPLICATION "
		        ]
	        ]
        	
	        /* Specify if the new column is a row GUID column.*/
	        [ LookupProperty( "Row_GUID", "1", " ROWGUIDCOL " ) ]
        	
	        /* Specify the default value for the column */
	        [
		        ForEachOwnee("Default_Constraint_Usage" )
		        {
			        <
				        PushReference( "Default_Ref" )
				        [
				            IsPropertyTrue( "Generate_As_SQL_92_Format" ) 
				            "\n\t\t" 
				            " DEFAULT  " 
				            Property( "Server_Value")
				        ]
				        Pop
			        >
		        }
	        ]

	        /* Specify the check constraint for the column */
	        [
        		
		        ForEachOwnee( "Check_Constraint_Usage" )
		        {
			        [
						Set( "var_bIsNotForReplication", "false" )
						[ 
						    IsPropertyTrue( "Is_Not_For_Replication" ) 
						    Set( "var_bIsNotForReplication", "true" ) 
						]
				        PushReference( "Validation_Rule_Ref" )
				        [
					        [IsPropertyTrue( "Generate_As_SQL_92_Format" )]
					        "\n\t\t"  
					        "CHECK  " 
					        [ 
					            Equal( Value( "var_bIsNotForReplication" ), "true" )  
					            "NOT FOR REPLICATION "
					        ]
					        "( " 
					        /*Property( "Server_Value" ) */
                            [FE::ExpandERwinMacro( "Server_Value" ) ]
					        " )"
				        ]
				        Pop
				        Remove( "var_bIsNotForReplication" )
			        ]
		        }
	        ]
        }
        
        Remove( "var_OrderListType" )
        /*Process constraint DDL*/
            [
                ",\n\t"
                <
                    ForEachOwnee( "Key_Group" )
                    {
                        [
                            Equal( Left( Property( "Key_Group_Type" ), 2 ), "PK" )
	                        
	                        " PRIMARY KEY "	
	                        [
	                            " "  
	                            LookupProperty( "Is_Clustered", "true", "CLUSTERED", "NONCLUSTERED" ) 
	                            " "
	                        ]
	                        "("
	                        <
		                        ForEachReference( "Index_Members_Order_Ref" )
		                        {
			                        ListSeparator( "," )
			                        QuotedName
			                        [
			                            " " 
			                            Property( "Key_Group_Sort_Order", "no_translate" )
			                        ]
		                        }
		                    >
	                        ")"

	                        [
                            	
		                        /* Specify the fill factor and the index options.*/
		                        [
			                        "\n\t" "WITH"
			                        "\n\t" "("
			                        "\n\t\t"
			                        <
				                        Separator
				                        (
				                            ",\n\t\t",
					                        [ "PAD_INDEX = "				LookupProperty( "SQLServer_Pad_Index", "true", "ON", "false", "OFF" )          ],
					                        [ "FILLFACTOR = "				< Property( "SQLServer_Fill_Factor" ) >                                        ],
					                        [ "IGNORE_DUP_KEY = "			LookupProperty( "SQLServer_Ignore_Duplicate_Keys", "true", "ON", "false", "OFF" )    ],
					                        [ "STATISTICS_NORECOMPUTE = "	LookupProperty( "SQLServer_Keep_Existing_Statistics", "true", "ON", "false", "OFF" )       ],
					                        [ "ALLOW_ROW_LOCKS = "			LookupProperty( "Allow_Row_Locks", "true", "ON", "false", "OFF" )               ],
						                    [ "ALLOW_PAGE_LOCKS = "			LookupProperty( "Allow_Page_Locks", "true", "ON", "false", "OFF" )              ],

					                        [ "SORT_IN_TEMPDB = "			LookupProperty( "SQLServer_Sort_In_Temp_DB",    "true", "ON", "false", "OFF" ) ],
					                        [ "ONLINE = "	        		LookupProperty( "Online",                       "true", "ON", "false", "OFF" ) ],
					                        [ "MAXDOP = "			        < Property( "SQLServer_Max_Parallel" ) >                                       ]  
				                        )
			                        >
			                        "\n\t"	
			                        ")"
		                        ]

		                        /*Specify the partition scheme or filegroup on which the table is stored.*/
		                        [
			                        "\n\t" 
			                        " ON " 
			                        <
				                        [
					                        PushReference( "SQL Server Partition Scheme Ref" ) 
					                            < Property( "Name" ) > 
					                        Pop
					                        "( "
					                        ForEachReference( "SQL Server Partition Columns Ref" )
					                        {
						                        ListSeparator( "," )
						                        < Property( "Physical_Name" ) >
					                        }
					                        " )"
				                        ]
				                        [
				                        PushReference( "SQLServer_File_Group_Ref" )  
				                            "\"" 
				                            < Property( "Name" ) > 
				                            "\"" 
				                        Pop
				                        ]
			                        >
		                        ]	
	                        ]
	                     ]
                    }
                >
            ]
        
        [
            ",\n\t"
            <
                ForEachOwnee( "Key_Group" )
                {
	                Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" )
	                ListSeparator( ",\n\t" )
	                
	                " UNIQUE " 
	                [
	                    "  " 
	                    LookupProperty( "Is_Clustered","true","CLUSTERED", "false", "NONCLUSTERED" )	
	                    " "
	                ]
	                "("
	                ForEachReference( "Index_Members_Order_Ref" )
	                {
		                ListSeparator( "," )
		                QuotedName
		                [
		                    "  "  
		                    Property( "Key_Group_Sort_Order", "no_translate" )
		                ]
	                }
	                ")"
	                [
		                /* Specify the fill factor and the index options.*/
		                [
			                "\n\t" 
			                "WITH"
			                "\n\t" 
			                "("
			                "\n\t\t"
			                <
			                    Separator
			                    (
			                        ",\n\t\t",
				                    [ "PAD_INDEX = "				LookupProperty( "SQLServer_Pad_Index", "true", "ON", "false", "OFF" )      ],
				                    [ "FILLFACTOR = " 				< Property( "SQLServer_Fill_Factor" ) >                                    ],
				                    [ "IGNORE_DUP_KEY = "			LookupProperty( "SQLServer_Ignore_Duplicate_Keys", "true", "ON", "false", "OFF" )],
				                    [ "STATISTICS_NORECOMPUTE = "	LookupProperty( "SQLServer_Keep_Existing_Statistics", "true", "ON", "false", "OFF" )   ],
				                    [ "ALLOW_ROW_LOCKS = "			LookupProperty( "Allow_Row_Locks", "true", "ON", "false", "OFF" )           ],
				                    [ "ALLOW_PAGE_LOCKS = "			LookupProperty( "Allow_Page_Locks", "true", "ON", "false", "OFF" )              ],

			                        [ "SORT_IN_TEMPDB = "			LookupProperty( "SQLServer_Sort_In_Temp_DB",    "true", "ON", "false", "OFF" ) ],
			                        [ "ONLINE = "	        		LookupProperty( "Online",                       "true", "ON", "false", "OFF" ) ],
			                        [ "MAXDOP = "			        < Property( "SQLServer_Max_Parallel" ) >                                       ]  
			                    )
			                >
			                "\n\t"	
			                ")"
		                ]

		                /*Specify the partition scheme or filegroup on which the table is stored.*/
		                [
			                "\n\t"	
			                " ON " 
			                <
				                [
					                PushReference( "SQL Server Partition Scheme Ref" ) 
					                    < Property( "Name" ) > 
					                Pop
					                "( "
					                ForEachReference( "SQL Server Partition Columns Ref" )
					                {
						                ListSeparator(  ",")
						                < Property( "Physical_Name" ) >
					                }
					                " )"
				                ]
				                [
				                PushReference( "SQLServer_File_Group_Ref" ) 
				                    "\"" 
				                    < Property( "Name" ) > 
				                    "\"" 
				                Pop
				                ]
			                >
		                ]	
	                ]
                }
             >
        ]
        
        [
            ",\n\t"
            <
	            ForEachOwnee( "Check_Constraint_Usage" )
	            {
		            PushReference( "Validation_Rule_Ref" )
		            @if ( IsPropertyTrue( "Generate_As_SQL_92_Format" ) )
		            {
			            Pop /*Pop the Validation Rule Ref*/

			            ListSeparator( ",\n" )
			            "\n\t\t"  
			            "CHECK  "
			            [ 
			                IsPropertyTrue( "Is_Not_For_Replication" )  
			                "NOT FOR REPLICATION " 
			            ]
			            [
			                "( " 
			                Property( "Server_Value") 
			                " ) "
			            ]
		            }
		            @else 
		            {
		                Pop
		            }
	            }
            >
        ]
        "\n" 
        ")"
        [
            "\n"
            /*Specify the partition scheme or filegroup on which the table is stored.*/
            [
	            "ON " 
	            <
		            [
			            PushReference( "SQLServer_Partition_Scheme_Ref" ) 
			                < Property( "Name" ) > 
			            Pop
			            "( "
			            ForEachReference( "Partition_Columns_Ref" )
			            {
				            ListSeparator(  ",")
				            < Property( "Physical_Name" ) >
			            }
			            " )"
		            ]
		            [
		            PushReference( "SQLServer_File_Group_Ref" ) 
		                "\"" 
		                < Property( "Name" ) > 
		                "\"" 
		            Pop
		            ]
	            >
            ]
        ]
        
        [
            "\n" 
            "TEXTIMAGE_ON "
            <
	            PushReference( "SQLServer_Text_Image_Ref" )
				    @if ( FE::Option( "QuoteName" ) )
				    { 
					    QuotedName 
				    }
				    @else
				    { 
					    "[" 
					    Property( "Name" ) 
					    "]" 
				    }
	            Pop
            >
        ] 

    ]
SPItemEnd

SPItemBegin [keep format] = Clause: Specify Database Extended Properties
[
	/* Generate comments */
	[
		FE::Option( "Comments")
		Equal( ObjectType, "SQLServer_Database" )

		"EXEC ('USE " 
		Property( "Name" ) 
		"; "
		<
			[ 
			    FE::IsSchemaGeneration 
				"EXEC sp_addextendedproperty \n@name = N''MS_Description'', @value = N''" 
				Property( "Definition" ) 
				"''"
			]
			[ 
			    FE::IsAlterScriptGeneration 
			    IsPropertyModified( "Definition" )
				"EXEC sp_updateextendedproperty \n@name = N''MS_Description'', @value = N''" 
				Property( "Definition" ) 
				"''" 
			]
		>
		"')" /* close EXEC */
		
		FE::EndOfStatement		
	]
	
	/* Generate the UDPs. */
	[
		FE::Option( "OtherOptionsUserDefinedProperties" )
		Equal( ObjectType, "SQLServer_Database" )
		Set("var_UserDefined",Property("User_defined"))
		ForEachProperty( "User_defined" )
		{
			"EXEC ('USE " 
			Property( "Name" ) 
			"; "
			<
				[ 
				    FE::IsSchemaGeneration
					"EXEC sp_addextendedproperty \n@name = N''"  
					ForEachProperty.Type  
					"'', @value = N''" 
					ForEachProperty.Value 
					"''"
				]
				[ 
				    FE::IsAlterScriptGeneration 
				    IsPropertyModified( Value("var_UserDefined") )
					"EXEC sp_updateextendedproperty \n@name = N''"  
					ForEachProperty.Type  
					"'', @value = N''" 
					ForEachProperty.Value 
					"''" 
				]
			>
			"')" /* close EXEC */

			FE::EndOfStatement
	 	}
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Specify Extended Properties
[
    OnceForObject( "Comment")
    
	/* Set the local flag to false. */
	Set( "var_bProceed", "false" )

	/* Generate comments */
	[
		FE::Option( "Comments" )
		Switch( Value( "var_Operation" ) )
		{
			Choose( "sp_addextendedproperty" )
			{
				Set( "var_bProceed", "true" )
			}
			Choose( "sp_updateextendedproperty" )
			{
			    [
				    IsPropertyModified( Value( "var_Comment" ) ) 
				    Set( "var_bProceed", "true" )
			    ]
			}
		}
		
		Equal( Value( "var_bProceed" ), "true" )
		Set( "var_ExtendedPropertyName", "MS_Description" )
		Set( "var_ExtendedPropertyValue", Property( Value( "var_Comment" ) ) )
		"EXEC " 
		Value( "var_Operation" )
		< Execute( "Clause: Specify Extended Property" )  >
	]
	
	/* Reset the local flag */
	Set( "var_bProceed", "false" )
	
	/* Generate the UDPs. */
	[
		FE::Option( "OtherOptionsUserDefinedProperties" )
		Set( "var_UserDefined", Property( "User Defined" ) )
		
		ForEachProperty( "UserDefined" )
		{
			Switch( Value( "var_Operation" ) )
			{
				Choose( "sp_addextendedproperty" )
				{
					Set( "var_bProceed", "true" )
				}
				Choose( "sp_updateextendedproperty" )
				{
					[
						IsPropertyModified( Value( "var_UserDefined" ) ) 
						Set( "var_bProceed", "true" )
					]
				}
			}
			
			Equal( Value( "var_bProceed" ), "true" )
			Set( "var_ExtendedPropertyName", ForEachProperty.Type )
			Set( "var_ExtendedPropertyValue", ForEachProperty.Value )
			"EXEC " 
			Value( "var_Operation" )
	 		< Execute( "Clause: Specify Extended Property" ) >
	 	}

	]

	/* Remove the variables */
	Remove( "var_bProceed" )
	[
		Equal( Value( "var_RemoveVariables" ), "true" )
		[ Remove( "var_Comment" )               ]
		[ Remove( "var_RemoveVariables" )       ]
		[ Remove( "var_ExtendedPropertyName" )  ] 
		[ Remove( "var_ExtendedPropertyValue" ) ]
		[ Remove( "var_Level0Type" )            ] 
		[ Remove( "var_Level0Name" )            ]
		[ Remove( "var_Level1Type" )            ] 
		[ Remove( "var_Level1Name" )            ]
		[ Remove( "var_Level2Type" )            ] 
		[ Remove( "var_Level2Name" )            ]
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Specify Extended Property
[
    "\n" "@name = "  "N'" < Value( "var_ExtendedPropertyName" ) > "'"
    ", "   "@value = "  "N'" < Substitute( Value( "var_ExtendedPropertyValue"), "''", "'" ) > "'"

    ",\n" "@level0type = "  "N'" < Value( "var_Level0Type" ) > "'"
    ", "   "@level0name = "  "N'" < Value( "var_Level0Name" ) > "'"

    [ ",\n" "@level1type = "  "N'" < Value( "var_Level1Type" ) > "'" ]
    [ ", "   "@level1name = "  "N'" < Value( "var_Level1Name" ) > "'" ] 
    
    [ ",\n" "@level2type = "  "N'" < Value( "var_Level2Type" ) > "'" ]
    [ ", "   "@level2name = "  "N'" < Value( "var_Level2Name" ) > "'" ]
    
    FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Attribute

	/* Initialie the variable */
	Set( "var_bUseAlter", "false" )
	
	[
	    FE::Option( "AlterStatements" ) 
	    Set( "var_bUseAlter", "true" )
	]
	[
		FE::Option( "!AlterStatements" )
		FE::IsLastColumn
		[
			LookupProperty( "Null_Option_Type", "1", "" )
			ForEachOwnee( "Default_Constraint_Usage" )
			{
				PushReference( "Default_Ref" )
				[
				    LookupProperty( "Generate_As_SQL_92_Format", "true", "" )
				    Set( "var_bUseAlter", "true" )
				]
				Pop
			}
		]
		[ 
		    LookupProperty( "Null_Option_Type", "1", "false", "true" ) 
		    Set( "var_bUseAlter", "true" )
		]
	]
	
	/* Do not alter if the entire entity was created. */
	@if ( Equal( Value( "var_bUseAlter" ), "true" ) )
	{
		[
			Set( "var_EntityIsCreated", "false" )
			PushOwner
			[
			    IsGlobalFlagSet( ObjectId "Create Entity" )
				Set( "var_EntityIsCreated", "true" )
			]
			Pop
			Equal( Value( "var_EntityIsCreated" ), "false" )
	
			FE::Bucket( "85" )
			FE::RecordAlter
			FE::RecordCreate /*?*/
		    	"ALTER TABLE "
			PushOwner
	            		[ FE::OwnerOverride( "true" ) "." ] 
		        	QuotedName
			Pop
			"\n" 
			"ADD "
			Property( "Physical_Name" ) 
			"  " 
			Execute( "Clause: AttributeDatatype" ) 
			"  " 
			[
			    IsNotInheritedFromUDD( "Null_Option_Type" )
				@if(IsPropertyNull("Expression" ))
				{
					LookupProperty( "Null_Option_Type", "0", "NULL", "1", "NOT NULL" )
				}
				@else
				{
					@if ( IsPropertyTrue( "SQLServer_Is_Persisted" ) )
	        		{
	            		"PERSISTED "
	            		LookupProperty( "Null_Option_Type","1","NOT NULL","" )
	            		" "
	        		}
	        		@else
	        		{
		        		/* Specify if null values are allowed in the column.*/
		        		IsPropertyNull("Expression" ) 
		        		" "
	        		}
				}
			]
	
			/*SQL Server does not allow Identity to be inherited from its UDD*/
	    	[ 
	    		[ 
	    		    LookupProperty( "Null_Option_Type", "8", "IDENTITY" ) 
	    		    " "
	    		] 
	    		[
	    		    "( " 
	    		    < Property( "Identity_Seed" ) >
	    		    " )" 
	    		    " "
	    		] 
	    	]
	    	
	    	 [
	            Set( "GenerateAsUDD", "false" )
	            PushReference("Parent Domain")
			    [
				    IsPropertyTrue("Generate As Udd")
				    Set("GenerateAsUDD","true")
				]
	            Pop
	            
	            [
	                Equal( Value("GenerateAsUDD"), "false" )
	                " COLLATE " <Property("Collation_Name")> " "        
	            ]
	            Remove("GenerateAsUDD")
	        ]
	
			Set( "var_bDefaultProperties", "false" )
			[
				FE::Option( "ColumnDefaultValue" )
				[
					ForEachOwnee( "Default_Constraint_Usage" )
					{
						/* LookupProperty( "Generate_As_SQL_92_Format", "true", "" ) */
						PushReference( "Default_Ref" )
						[
							LookupProperty( "Generate_As_SQL_92_Format", "true", "" ) 
							Set( "var_bBindDefaultProperties", "true" )
						] 
						Pop
					    	[ 
							Equal( Value( "var_bBindDefaultProperties" ) , "true" ) 
					        		" CONSTRAINT  " 
					        		FE::Option( "ConstraintName" ) 
					        		Property( "Physical_Name" )
					    	]
					    	[
						    	PushReference( "Default_Ref" )
						    	[
								LookupProperty( "Generate_As_SQL_92_Format", "true", "" ) 
							    	"\n\t\t" 
							    	" DEFAULT  " 
                                    FE::ExpandERwinMacro( "Server_Value" )
							    	Set( "var_bDefaultProperties", "true" )
						    	]
						    	Pop
					    	]
					} 
				]
			]
			
			Set( "var_bCheckProperties", "false" )
			[
				FE::Option( "ColumnCheckConstraint" )
				[
					ForEachOwnee( "Check_Constraint_Usage" )
					{
					[ 
					    " CONSTRAINT  " 
					    FE::Option( "ConstraintName" ) 
					    Property( "Physical_Name" )
					]
					[
						Set( "var_bIsNotForReplication", "false" )
						[ 
						    IsPropertyTrue( "Is_Not_For_Replication" ) 
						    Set( "var_bIsNotForReplication", "true" ) 
						]
						PushReference( "Validation_Rule_Ref" )
						[
							LookupProperty( "Generate_As_SQL_92_Format", "true", "" )
							"\n\t\t"  
							"CHECK  " 
							[ 
							    Equal( Value( "var_bIsNotForReplication" ) , "true" ) 
							    "NOT FOR REPLICATION "
							]
							"( " 
                            FE::ExpandERwinMacro( "Server_Value" ) 
							" ) "
							Set( "var_bCheckProperties", "true" )
						]
						Pop
						Remove( "var_bIsNotForReplication" )
					]
					}/*Pop*/
				]
			]
	
			FE::EndOfStatement
	
			[
				Equal( Value( "var_bDefaultProperties" ), "false" )
				ForEachOwnee("Default_Constraint_Usage")
				{
					Execute( "Create Default_Constraint_Usage" )
				}
			]
	
			[
				Equal( Value( "var_bCheckProperties" ), "false" )
				Execute( "Create Check_Constraint_Usage" )
			]
			
			Remove( "var_bDefaultProperties" )
			Remove( "var_bCheckProperties" )
		]
	}
	@else
	{
		PushOwner
			Execute( "Generate Entity" )
		Pop
	}
	Remove( "var_bUseAlter" )
	Remove( "var_bProceed" )
	Remove( "var_EntityIsCreated" )

SPItemEnd

SPItemBegin [keep format] = Create Check_Constraint_Usage
	[
		/* Check the format in which the validation rule is to be generated */
		Set( "var_SQL92Format", "true" )
		[
			PushReference( "Validation_Rule_Ref" )
			[
			    IsPropertyFalse( "Generate_As_SQL_92_Format" ) 
			    Set( "var_SQL92Format", "false" )
			]
			Pop
		]
		
		/* Check if the owner is an Attribute */
		Set( "var_OwnerIsAttribute", "false" )
		[
		    PushOwner
		    [
			    Equal( ObjectType, "Attribute" )
			    PushOwner
			    [
				    Equal( ObjectType, "Entity" )
				    Set( "var_OwnerIsAttribute", "true" )
			    ]
			    Pop
		    ]
		    Pop
		]
			
		/* Bind to the column to the validation rule. */
		[
			Equal( Value( "var_SQL92Format" ), "false" )
			Equal( Value( "var_OwnerIsAttribute" ), "true" )
			
			OnceForObject( "Create Check_Constraint_Usage" )
			IsNotInheritedFromUDD
			FE::Bucket( "94" )
			PushReference( "Validation_Rule_Ref" )
				"exec sp_bindrule "
			    "'"
			    [ FE::OwnerOverride( "true" ) "." ]
			    < QuotedName >
			    "'"
			    ", "
			Pop
	
			"'"
			PushOwner
				PushOwner
			    [
		            [ FE::OwnerOverride( "true" ) "." ]
		            < QuotedName >
			    ]
		        Pop
				"." 
				QuotedName
			Pop
			"'"
			FE::EndOfStatement
		]
		
		/* Bind to the domain to the validation rule. */
		[	
			Equal( Value( "var_SQL92Format" ), "false" )
			PushOwner
				[
				    Equal( ObjectType, "Domain" ) 
				    Set( "var_OwnerIsDomain", "true" )
				]
			Pop
			Equal( Value( "var_OwnerIsDomain" ), "true" )
			
			OnceForObject( "Create Check_Constraint_Usage" )
			FE::Bucket( "94" )
			PushReference( "Validation_Rule_Ref" )
				"exec sp_bindrule "
			    "'"
		        	[ FE::OwnerOverride( "true" ) "." ]
		        	< QuotedName >
		        	"'"
			    ", "
			Pop
	
			PushOwner
				QuotedName
			Pop
			FE::EndOfStatement
		]
	
		/* Pop back to original object if necessary. */
		[
		    Equal( ObjectType, "Validation_Rule") 
		    
		    Pop
		]
	
		/* Create the column level constraint for the validation rule. */
		[
			Equal( Value( "var_OwnerIsAttribute" ), "true" )
			Equal( Value( "var_SQL92Format" ), "true" )
			
			Set( "var_AttCreated", "false" )
			Set( "var_EntCreated", "false" )
			
			PushOwner
				[
					IsGlobalFlagSet( ObjectId "Create Attribute" )
					Set( "var_AttCreated", "true" )
				]
				[
				    PushOwner
				    [
					    IsGlobalFlagSet( ObjectId "Create Entity" )
					    Set( "var_EntCreated", "true" )
				    ]
				    Pop
				]
			Pop
			Equal( Value( "var_AttCreated" ),"false" )
			Equal( Value( "var_EntCreated" ),"false" )
			
			/* There is no way to alter a column level constraint value,
			*  so drop and recreate the entire table.
			*/
			PushOwner
				PushOwner
				    FE::Bucket( "1000000" ) 
				    "\n"
				    "/* Table "
				    [
				        PushReference( "Schema_Name" )
				            QuotedName
				        Pop
				        "."
				    ]
				    QuotedName
				    " dropped and recreated due to the addition of a column level check constraint. */"
				    Execute( "Generate Entity" )
				Pop
			Pop
		]
	
		/* Pop back to original object if necessary. */
		[
		    Equal( ObjectType, "Validation_Rule" ) 
		    Pop
		]
	
		Remove( "var_OwnerIsAttribute" )
		Remove( "var_OwnerIsDomain" )
		Remove( "var_SQL92Format" )
		Remove( "var_AttCreated" )
		Remove( "var_EntCreated" )
	]

SPItemEnd

SPItemBegin [keep format] = Create Constraint
	[
		/* Creates a PK, AK	(Unique), or FK table constraint for a single key group.*/
	
		/* Build alter table constraint statement.*/
	
		[
			FE::Option( "PKConstraintInAlter" )
			Equal( Left( Property( "Key_Group_Type" ), 2 ), "PK")
			FE::Bucket( "93" )
			PushOwner
				"ALTER TABLE " 
                			[ FE::OwnerOverride( "true" ) "." ] 
                			QuotedName
                			"\n"
			Pop
			/* Append one of the following constraints. Each is guarded by Key Group type. */
			"ADD "
			< Execute( "Clause: PKConstraint" ) >
			FE::EndOfStatement
		]
	
		[
			FE::Option( "AKConstraintInAlter" )
			Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK")
			FE::Bucket( "93" )
			PushOwner
				"ALTER TABLE " 
                			[ FE::OwnerOverride( "true" ) "." ] 
                			QuotedName
                			"\n"
			Pop
			/* Append one of the following constraints. Each is guarded by Key Group type. */
			"ADD "
			< Execute( "Clause: AKConstraint" ) >
			FE::EndOfStatement
		]
		[
			FE::Option( "FKConstraintInAlter" )
			Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" )
			FE::Bucket( "94" )
			PushOwner
				"ALTER TABLE " 
                			[ FE::OwnerOverride( "true" ) "." ] 
                			QuotedName
			Pop
            			[ 
	            			PushReference( "Relationship_Ref" )
                    			[ LookupProperty( "Force_Checking_Of_Existing_Data", "true", " WITH CHECK ", "false", " WITH NOCHECK " ) ]
                				Pop
           			]
			"\n\t" 
			/* Append one of the following constraints. Each is guarded by Key Group type. */
			"ADD "
			< Execute( "Clause: FKConstraint" ) >
			FE::EndOfStatement
		]
	]

SPItemEnd

SPItemBegin [keep format] = Create Default

	[
		FE::Bucket( "56" )
		IsPropertyFalse( "Generate_As_SQL_92_Format" )

		OnceForObject( "Create Default" ) 
		FE::Option( "CreateDefault" )
		[
			"CREATE DEFAULT "
			
			[ FE::OwnerOverride( "true" ) "." ] 
			< QuotedName >
			"\n\t" 
			"AS " 
            < FE::ExpandERwinMacro( "Server_Value" ) >
			FE::EndOfStatement
		]
	]

SPItemEnd

SPItemBegin [keep format] = Create Default_Constraint_Usage
	[
		/* Bind to the column to the default value.	*/
		[
			PushOwner
			[
				Equal( ObjectType, "Attribute" )
				PushOwner
				[
					Equal( ObjectType, "Entity" )
					Set( "var_OwnerIsAttribute", "true" )
				]
				Pop
			]
			Pop
	
			Equal( Value( "var_OwnerIsAttribute" ), "true" )
			
			PushReference( "Default_Ref" )
			@if ( IsPropertyFalse( "Generate_As_SQL_92_Format" ) )
			{
				Pop
				
				IsNotInheritedFromUDD
				OnceForObject( "Create Default_Constraint_Usage" )
				FE::Bucket( "94" )
				FE::RecordAlter
				PushReference( "Default_Ref" )
				    "exec sp_bindefault "
				    "'"
				    [ FE::OwnerOverride( "true" ) "." ]
				    QuotedName 
				    "'"
				    ", "
				Pop
		
				PushOwner
					PushOwner 
					    "'"
						[ FE::OwnerOverride( "true" ) "." ]
						QuotedName
					Pop
					"." 
					QuotedName 
					"'"
				Pop
				FE::EndOfStatement
			}
			@else
			{ 
			    Pop 
			}
		]
	
		/* Bind to the domain to the default value.	*/
		[
			PushOwner
			[
				Equal( ObjectType, "Domain" ) 
				Set( "var_OwnerIsDomain", "true" )
			]
			Pop
	
			Equal( Value( "var_OwnerIsDomain" ), "true" )
	
			IsPropertyFalse( "Default Is SQL 92" )
			OnceForObject( "Create Default_Constraint_Usage" )
			FE::Bucket( "94" )
			FE::RecordAlter
			PushReference( "Default_Ref" )
			[
				"exec sp_bindefault "
				"'"
				[ FE::OwnerOverride( "true" ) "." ]
				QuotedName 
				"'"
				", "
			]
			Pop
	
			PushOwner
				"'"
				[ FE::OwnerOverride( "true" ) "." ]
				QuotedName
				"'"
			Pop
			FE::EndOfStatement
		]
	
		/* Pop back to original object if necessary. */
		[ 
		    Equal( ObjectType, "Default" ) 
		    
		    Pop 
		]
	
		/* Create the column level default value. */
		[
			Equal( Value( "var_OwnerIsAttribute" ), "true" )
	
			Set( "var_AttIsCreated", "false" )
			PushOwner
			    [
			        IsGlobalFlagSet( ObjectId "Create Attribute" ) 
			        Set( "var_AttIsCreated", "true" )
			    ]
			    [
			        PushOwner 
			        [
			            IsGlobalFlagSet( ObjectId "Create Entity" ) 
			            Set( "var_AttIsCreated", "true" )
			        ] 
			        Pop
			    ]
			Pop
			Equal( Value( "var_AttIsCreated" ), "false" )
	
			PushReference( "Default_Ref" )
			[
			    IsPropertyTrue( "Generate_As_SQL_92_Format" ) 
			    Set( "var_SQL92Format", "true" )
			]
			Pop
			Equal( Value( "var_SQL92Format" ), "true" )
			FE::Bucket( "93" ) 
			"\n"
			FE::RecordAlter
			PushOwner
				PushOwner
					"ALTER TABLE " 
					[ FE::OwnerOverride( "true" ) "." ] 
					QuotedName
				Pop
			Pop
			" ADD "   
			[
			    FE::Option( "ConstraintName" ) 
			    "CONSTRAINT " 
			    QuotedName
			]
			" DEFAULT "
			[
				PushReference( "Default_Ref" )
                    [ FE::ExpandERwinMacro( "Server_Value" ) ]
				Pop
			]
			" FOR " 
			PushOwner 
			    QuotedName 
			Pop
			FE::EndOfStatement
		]
	
		/* Pop back to original object if necessary. */
		[
		    Equal( ObjectType, "Default" ) 
		    
		    Pop
		]
	
		Remove( "var_OwnerIsAttribute" )
		Remove( "var_OwnerIsDomain" )
		Remove( "var_AttIsCreated" )
		Remove( "var_SQL92Format" )
	]

SPItemEnd

SPItemBegin [keep format] = Create Domain
	[
		IsPropertyTrue( "Generate_As_User_Defined_Type" )
		FE::Option( "CreateUserDefinedType" ) 
		OnceForObject( "Create Domain" ) 
		ShouldGenerate
		[
			[
				FE::Bucket( "56" )
				"CREATE TYPE " 
				
				/* Specify the name of the schema to which the datatype belongs.*/
	            			[ FE::OwnerOverride( "true" ) "." ] 
				/*Name of the datatype.*/
				< QuotedName >

				"\n\t"
				<
					@if ( Equal( Property( "SQLServer_Code_Type" ), "Assembly" ) )
					{
						"EXTERNAL NAME "
						< 
						    PushReference( "SQLServer_Assembly_Ref" ) 
						    Property( "Name" ) 
						    Pop
						>
						[
						    ".[" 
						    < Property( "SQLServer_Class_Name" ) > 
						    "]"
						]
					}
					@else
					{
						[
							"FROM " 
							/*Base Type*/
							[ 
							    FE::Option( "QuoteName" ) 
							    "\""
							] 
							< UpperCase( Property( "Physical_Data_Type" ) ) > 
							[ 
							    FE::Option( "QuoteName" ) 
							    "\"" 
							]
							
							/* Process the Null Option. 
							If Domain is set to Identity or Not Null, emit NOT NULL. */
							[ 
							    " " 
							    < LookupProperty( "Null_Option_Type", "0", "NULL", "NOT NULL" ) > 
							]
						]
					}
				>
				FE::EndOfStatement
			]
	
			[
				FE::Bucket( "57" ) 
				"\n"
				"exec sp_bindefault "
				<
					ForEachOwnee( "Default_Constraint_Usage" )
					{
						IsNotInheritedFromUDD
						OnceForObject( "Create Default_Constraint_Usage" )
						<
						    PushReference( "Default_Ref" )
						    [
							    IsPropertyFalse( "Generate_As_SQL_92_Format" ) 
							    "'"
							    [ FE::OwnerOverride( "true" ) "." ]
							    Property( "Physical_Name" )
							    "'"
						    ]
						    Pop
						>
					}
				>
				", '"
                				[ FE::OwnerOverride( "true" ) "." ]				
                				QuotedName
				"'"
				FE::EndOfStatement
			]
			[
				FE::Bucket( "57" ) 
				"\n"
				"exec sp_bindrule "
				<
					ForEachOwnee( "Check_Constraint_Usage" )
					{
						IsNotInheritedFromUDD
						OnceForObject( "Create Check_Constraint_Usage" )
						<
						    PushReference( "Validation_Rule_Ref" )
							[ 
							    IsPropertyFalse( "Generate_As_SQL_92_Format" )
			                    "'"
			                    [ FE::OwnerOverride( "true" ) "." ]
			                    < QuotedName >
			                    "'"
			                ]
						    Pop
						>
					}
				>
				", '"
				[ FE::OwnerOverride( "true" ) "." ]
				QuotedName
				"'"
				FE::EndOfStatement
			]
			
			/* Generate comments and UDP's as Extended Properties. */
			[
				/* Set the variables required by the "Clause: Specify Extended Properties". */
				Set( "var_RemoveVariables", "true" ) 
				Set( "var_Operation", "sp_addextendedproperty" ) 
				Set( "var_Comment", "Comment" )
				Set( "var_Level0Type", "TYPE" ) 
				Set( "var_Level0Name", Property( "Name" ) )
				
				/* Generate Domain comments and UDPs */
				Execute( "Clause: Specify Extended Properties" )
			]			
			[ 
		    	FE::Bucket( "150" ) 
				ForEachOwnee( "Permission" )
				{
					Execute( "Create Permission" )
				}
			]
		]
	]

SPItemEnd

SPItemBegin [keep format] = Create Entity
[
    ShouldGenerate
    
    /* Make sure that Create Entity is executed only once. */
    OnceForObject( "Create Entity" )
    
    /* Is the "TablePreScript" option turned on? */   
    [ 
        FE::Option( "TablePreScript" )
        ForEachReference( "Script_Templates_Ref", "require_one" )
        {
            [ 
                ShouldGenerate 
                IsPropertyTrue( "Generate_As_Pre_Script" )
                FE::Bucket( "90" )
                FE::ExpandERwinMacro( "Template_Code" )
                FE::EndOfStatement( "true" )
            ]
        }
    ]
    /* end TablePreScript */
 

    [ 
        FE::Option( "CreateTable" )
        
        /* We need to set this flag to indicate to the internal post process */
        /* that the entity has been created. Post process uses this flag to  */
        /* determine whether alter statements have been superceded by this   */
        /* create statement. (the same as old FESetStringX)                  */

        FE::RecordCreate
        SetGlobalFlag( ObjectId "Create Entity" )
        
        FE::Bucket( "90" )
        "CREATE TABLE " 
		/* Name of the new Table.*/
	    [ FE::OwnerOverride( "true" ) "." ] 
		< QuotedName >
	
		"\n( "
		@if ( FE::Option( "ColumnPhysicalOrder" ) )
		{
			Set( "var_OrderListType", "Physical_Columns_Order_Ref" )
		}
		@else
		{
			Set( "var_OrderListType", "Columns_Order_Ref" )
		}
		/*Process column properties*/
		<
			ForEachReference( Value( "var_OrderListType" ) )
			{
			    Set("GenerateAsUDD","false")
				ListSeparator( "," )
				"\n\t" 
				
				/* Name of the column */
				Pad( QuotedName, 20 ) " "
				
				/* Specify the datatype. */
                				Execute( "Clause: AttributeDatatype" )				
				" "
				/* Specify the xml schema collection if the datatype is an xml type. */
				[
					IsPropertyNull( "Expression" )
					Equal( Property( "Physical_Data_Type" ), "xml" )
					"( "
					
					[ 
					    UpperCase( Property( "SQLServer_XML_Document_Type" ) ) 
					    " " 
					]
					
					<
						PushReference( "SQLServer_XML_Schema_Collection_Ref" )
						@if ( FE::OwnerOverride ) 
						{
							FE::OwnerOverride "."
						}
						@else 
						{
							FE::Option( "SpecifyOwner" ) 
							PushReference( "Schema_Ref" ) 
							[
								< QuotedName >
								"."
							] 
							Pop
						}
						QuotedName
						Pop
					>
					" )"
				]

				
				 /* Specify the collation for the column if the underlying datatype is not User Defined.*/
	            [
	                Equal(Value("GenerateAsUDD"),"false")
				    Set( "var_sDatatype", Property("Physical_Data_Type") )
				    Set( "var_bSuceed", "false" )
				    @if( Equal( Left( Value("var_sDatatype"), "4"), "char") )
				    {
					    Set( "var_bSuceed", "true" )
				    }
    				
				    @if( Equal( Left( Value("var_sDatatype"), "7"), "varchar") )
				    {
					    Set( "var_bSuceed", "true" )
				    }
    				
				    @if( Equal( Left( Value("var_sDatatype"), "4"), "text") )
				    {
					    Set( "var_bSuceed", "true" )
				    }
    				
				    @if( Equal( Left( Value("var_sDatatype"), "5"), "nchar") )
				    {
					    Set( "var_bSuceed", "true" )
				    }
    				
				    @if( Equal( Left( Value("var_sDatatype"), "8"), "nvarchar") )
				    {
					    Set( "var_bSuceed", "true" )
				    }
    				
				    @if( Equal( Left( Value("var_sDatatype"), "5"), "ntext") )
				    {
					    Set( "var_bSuceed", "true" )
				    }
    					
				    [
					    Equal( Value("var_bSuceed"), "true" )
					    "COLLATE " <Property("Collation_Name")> " "
				    ]
    				
				    Remove( "var_sDatatype" )
				    Remove( "var_bSuceed" )
	            ]

    			
			    Remove("GenerateAsUDD")
				
				/* Check if the computed column is persisted. */
				@if ( IsPropertyTrue( "SQLServer_Is_Persisted" ) )
				{
					[
						"PERSISTED "
						LookupProperty( "Null_Option_Type", "1", "NOT NULL", "" )
						" "
					]
				}
				@else
				{
					/* Specify if null values are allowed in the column.*/
					[ 
					    IsPropertyNull( "Expression" ) 
					    IsNotInheritedFromUDD( "Null_Option_Type" )
						" " 
						LookupProperty( "Null_Option_Type", "0", "NULL", "1", "NOT NULL" )
						" " 
					]
				}
			
				/*SQL Server does not allow Identity to be inherited from its UDD*/
				[ 
					[ 
					    LookupProperty( "Null_Option_Type", "8", "IDENTITY" ) 
					    " " 
					] 
					[ 
					    "( " 
					    < Property( "Identity_Seed" ) >
					    " )" 
					    " "
					]
					[ 
					    IsPropertyTrue( "Is_Not_For_Replication" ) 
					    "NOT FOR REPLICATION " 
					]
				]
				
				/* Specify if the new column is a row GUID column.*/
				[ LookupProperty( "Row_GUID", "1", " ROWGUIDCOL " ) ]
				
				/* Specify the default value for the column */
				[
					FE::Option( "ColumnDefaultValue" )
					FE::Option( "ColumnDefaultInCreate" )
					ForEachOwnee( "Default_Constraint_Usage" )
					{
						[ 
						    "\n\t" 
						    FE::Option( "ConstraintName" ) 
						    [ 
						        "CONSTRAINT " 
						        QuotedName 
						    ] 
						]
						<
							PushReference( "Default_Ref" )
						    [ 
						        IsPropertyTrue( "Generate_As_SQL_92_Format" ) 
						        "\n\t\t" 
						        " DEFAULT  " 
                                FE::ExpandERwinMacro( "Server_Value" )
						    ]
							Pop
						>
					}
				]
				[
					FE::Option( "ColumnCheckConstraint" )
					FE::Option( "ColumnConstraintInCreate" )
					ForEachOwnee( "Check_Constraint_Usage" )
					{
						@ifnot(IsPropertyNotNull("Force_Checking_Of_Existing_Data"))
						{
							[ "\n\t" FE::Option( "ConstraintName" ) 
						    		[ "CONSTRAINT " QuotedName ] 
							]
							<
								Set( "var_bIsNotForReplication", "false" )
								[ 
							    	IsPropertyTrue( "Is_Not_For_Replication" ) 
							    	Set( "var_bIsNotForReplication", "true" ) 
								]
								PushReference( "Validation_Rule_Ref" )
								[
									IsPropertyTrue( "Generate_As_SQL_92_Format" )
									"\n\t\t"  
									"CHECK  " 
									[ 
                              			Equal( Value( "var_bIsNotForReplication" ) , "true" )
                                    	"NOT FOR REPLICATION " 
                                	]
									"( " 
                                    FE::ExpandERwinMacro( "Server_Value" ) 
									" )"
								]
								Pop
								Remove( "var_bIsNotForReplication" )
							>
						}
					}
				]
			}
		>

		Remove( "var_OrderListType" )
		/*Process constraint DDL*/
		[
			",\n\t"
			FE::Option( "PKConstraintInCreate" )
			<
			    ForEachOwnee( "Key_Group" )
			    {
				    < Execute( "Clause: PKConstraint" ) >
			    }
			>
		]

		[
			",\n\t"
			FE::Option( "AKConstraintInCreate" )
			<
			    ForEachOwnee( "Key_Group" )
			    {
				    Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" )
				    ListSeparator( ",\n\t" )
				    < Execute( "Clause: AKConstraint" ) >
			    }
			>
		]

		[
			",\n\t"
			FE::Option( "FKConstraintInCreate" )
			<
				ForEachOwnee( "Key_Group" )
				{	
					Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" )
					ListSeparator( ",\n" )
					< Execute( "Clause: FKConstraint" ) >
				}
			>
		]

		[
			FE::Option( "TableCheckConstraint" )
			FE::Option( "TableConstraintInCreate" )
			<
				ForEachOwnee( "Check_Constraint_Usage" )
				{
					@ifnot(IsPropertyNotNull("Force_Checking_Of_Existing_Data"))
					{
						PushReference( "Validation_Rule_Ref" )
						@if ( IsPropertyTrue( "Generate_As_SQL_92_Format" ) )
						{
							Pop /*Pop the Validation Rule Ref */
	
							",\n\t"
							[ 
						    	"CONSTRAINT  "	
						    	FE::Option( "ConstraintName" ) 
						    	< QuotedName > 
							]
							"\n\t\t"  
							"CHECK  "
							[ 
						    	IsPropertyTrue( "Is_Not_For_Replication" ) 
						    	"NOT FOR REPLICATION " 
							]
							[ 
						    	"( " 
                                FE::ExpandERwinMacro( "Server_Value" ) 
						    	" ) " 
							]
						}
						@else 
						{ 
					    	Pop 
						}
					}
				}
			>
		]

		"\n" 
		")"       

		[					
			/*Specify the partition scheme or filegroup on which the table is stored.*/
			[
				"\n"
				"ON " 
				<
					[
						FE::Option( "TablePartitions" )
						PushReference( "SQLServer_Partition_Scheme_Ref" ) 
						    < Property( "Name" ) > 
						Pop
						"( "
						<
							ForEachReference( "Partition_Columns_Ref" )
							{
								ListSeparator( "," )
								< Property( "Physical_Name" ) >
							}
						>
						" )"
					]
					[
					    FE::Option( "TablePhysicalStorage" )
					    PushReference( "SQLServer_File_Group_Ref" ) 
					        "\"" 
					        < Property( "Name" ) > 
					        "\"" 
					    Pop
					]
				>
			]
		]

		[
			"\n" 
			"TEXTIMAGE_ON "
			<
				PushReference( "SQLServer_Text_Image_Ref" )
				    @if ( FE::Option( "QuoteName" ) )
				    { 
					    QuotedName 
				    }
				    @else
				    { 
					    "[" 
					    Property( "Name" ) 
					    "]" 
				    }
				Pop
			>
		]
		FE::EndOfStatement
	]
	[
		/* Specify the check constraint for the column */
		[ 
			FE::Option( "ColumnCheckConstraint" )							
			FE::Option( "ColumnConstraintInCreate" )
			@if ( FE::Option( "ColumnPhysicalOrder" ) )
			{
				Set( "var_OrderListType", "Physical_Columns_Order_Ref" )
			}
			@else
			{
				Set( "var_OrderListType", "Columns_Order_Ref" )
			}
			/*Process column properties*/
			<
				ForEachReference( Value( "var_OrderListType" ) )
				{
					ForEachOwnee( "Check_Constraint_Usage" )
					{
						@if(IsPropertyNotNull("Force_Checking_Of_Existing_Data"))
					    {
							PushOwner
					    	PushOwner
						   		"ALTER TABLE " 
						    	
						   		[ FE::OwnerOverride( "true" ) "." ] 
						   		< QuotedName >
						   	
					    	Pop
					    	Pop
					    	"\n\t" 
				        	[ 
				         		LookupProperty("Force_Checking_Of_Existing_Data","true"," WITH CHECK ","false"," WITH NOCHECK ")
				        	]
							"ADD "
							[ FE::Option( "ConstraintName" ) 
								[ "CONSTRAINT " QuotedName ] 
							]
							" "
							<
								Set( "var_bIsNotForReplication", "false" )
								[ 
						   			IsPropertyTrue( "Is_Not_For_Replication" ) 
						    			Set( "var_bIsNotForReplication", "true" ) 
								]
								PushReference( "Validation_Rule_Ref" )
								[
									IsPropertyTrue( "Generate_As_SQL_92_Format" )
									"CHECK  " 
									[
                                		Equal( Value( "var_bIsNotForReplication" ) , "true" )
                                		"NOT FOR REPLICATION " 
                            		]
									"( " 
                                    FE::ExpandERwinMacro( "Server_Value" ) 
									" )"
								]
								Pop
								Remove( "var_bIsNotForReplication" )
							>
							FE::EndOfStatement
						}
					}
					[	
						ForEachOwnee( "Check_Constraint_Usage" )
						{
							@if(IsPropertyTrue("Is_Disabled"))
							{
								@if(IsPropertyNotNull("Force_Checking_Of_Existing_Data"))
								{
									Set( "var_SQL92Format", "false" )
									[
										PushReference( "Validation_Rule_Ref" )
										[
			    							IsPropertyTrue( "Generate_As_SQL_92_Format" ) 
			    							Set( "var_SQL92Format", "true" )
										]
										Pop
									]
									Equal(Value("var_SQL92Format"),"true") 
									PushOwner
					    				PushOwner
						    				"ALTER TABLE " 
						        				[ FE::OwnerOverride( "true" ) "." ] 
						    				< QuotedName >
						        			Pop
					    				Pop
					    				"\n\t" " "
									[
										LookupProperty("Force_Checking_Of_Existing_Data","true"," WITH CHECK ","false"," WITH NOCHECK ")
									]
									" NOCHECK "
									<
										[ 
											FE::Option( "ConstraintName" ) 
						    					[ "CONSTRAINT " QuotedName ] 
										]
									>
									FE::EndOfStatement
								}
							}
						}
					]
				}
			>
		]
		/* Generate PK constraint and its corresponding Index */
		[
			ForEachOwnee( "Key_Group" )
			{
				[
					Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
					[ 
					    FE::Bucket( "90" ) 
					    Execute( "Create Key_Group" ) 
					]
					[
						IsPropertyTrue( "Generate_As_Constraint" )
						FE::Option( "PKConstraintInAlter" )
						FE::Bucket( "90" )
						"ALTER TABLE "
						PushOwner
						    [ FE::OwnerOverride( "true" ) "." ] 
						    QuotedName
						Pop
						"\n\t" 
						"ADD "
						< Execute( "Clause: PKConstraint" ) >
				        		FE::EndOfStatement
					]
				]
			}
		]
		
	
		/*	Generate Unique constraints and its corresponding Index*/
		[
			ForEachOwnee( "Key_Group" )
			{
				Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" )
				[
					FE::Bucket( "90" )
					Execute( "Create Key_Group" )
				]
				[
					IsPropertyTrue( "Generate_As_Constraint" )
					FE::Option( "AKConstraintInAlter" )
					FE::Bucket( "90" )
					"ALTER TABLE "
					PushOwner
					
					[ FE::OwnerOverride( "true" ) "." ] 
					QuotedName
					
					Pop
					"\n\t" 
					"ADD "
					< Execute( "Clause: AKConstraint" ) >
				    	FE::EndOfStatement
				]
			}
		]
	
		/*Generate non-unique indexes (IE and IF)*/
		[
			ForEachOwnee( "Key_Group" )
			{
				NotEqual( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
				NotEqual( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
				[ 
				    FE::Bucket( "90" ) 
				    Execute( "Create Key_Group" )
				]
			}
		]
		
		/*Generate XML indexes*/
		[
		    /* Generate primary index first, then secondary indexes */
			ForEachOwnee( "SQLServer_XML_Index" )
			{
			    [
				    IsPropertyTrue( "Is_Primary_XML_Index" )
				    Execute( "Generate SQLServer_XML_Index" )
			    ]
			}

			ForEachOwnee( "SQLServer_XML_Index" )
			{
			    [
				    IsPropertyFalse( "Is_Primary_XML_Index" )
				    Execute( "Generate SQLServer_XML_Index" )
			    ]
			}			
		]
		
		/*Generate Fulltext indexes*/
		[
			ForEachOwnee( "SQLServer_Fulltext_Index" )
			{
				Execute( "Generate SQLServer_Fulltext_Index" )
			}
		]
	
		/* table constraint in alter */
		[
			FE::Option( "TableCheckConstraint" )
			FE::Option( "TableConstraintInAlter" )
			FE::Bucket( "94" ) "\n"
			ForEachOwnee( "Check_Constraint_Usage" )
			{
			    [
				    PushOwner
					    "ALTER TABLE " 
						[ FE::OwnerOverride( "true" ) "." ] 
						QuotedName
				    Pop
				    <
					    PushReference( "Validation_Rule_Ref" )
					    @if ( IsPropertyTrue( "Generate_As_SQL_92_Format" ) )
					    {
						    Pop /*Pop the Validation Rule Ref*/
						    [ 
						        [ 
						            LookupProperty( "Force_Checking_Of_Existing_Data", "true", " WITH CHECK ", "false", " WITH NOCHECK " ) 
						        ]
						        "\n\t" 
						        "ADD CONSTRAINT  "	
						        FE::Option( "ConstraintName" ) 
						        < QuotedName > 
						    ]
						    "\n\t\t"  
						    "CHECK  "
						    [ 
						        IsPropertyTrue( "Is_Not_For_Replication" ) 
						        "NOT FOR REPLICATION " 
						    ]
						    [
						        "( " 
                                FE::ExpandERwinMacro( "Server_Value" ) 
						        " ) "
						    ]
					    }
					    @else 
					    { 
					        Pop 
					    }
				    >
				    FE::EndOfStatement				
			    ]
			}
		]
				/* table constraint in alter */
		[
			FE::Option( "TableCheckConstraint" )
			FE::Option( "TableConstraintInCreate" )
			FE::Bucket( "94" ) "\n"
			ForEachOwnee( "Check_Constraint_Usage" )
			{
				@if(IsPropertyNotNull("Force_Checking_Of_Existing_Data"))
				{
			    	[
				    	PushOwner
					    	"ALTER TABLE " 
							[ FE::OwnerOverride( "true" ) "." ] 
							QuotedName
				    	Pop
				    	<
					    	PushReference( "Validation_Rule_Ref" )
					    	@if ( IsPropertyTrue( "Generate_As_SQL_92_Format" ) )
					    	{
						    	Pop /*Pop the Validation Rule Ref*/
						    	[ 
						        	[ 
						            	LookupProperty( "Force_Checking_Of_Existing_Data", "true", " WITH CHECK ", "false", " WITH NOCHECK " ) 
						        	]
						        	"\n\t" 
						        	"ADD CONSTRAINT  "	
						        	FE::Option( "ConstraintName" ) 
						        	< QuotedName > 
						    	]
						    	"\n\t\t"  
						    	"CHECK  "
						    	[ 
						        	IsPropertyTrue( "Is_Not_For_Replication" ) 
						        	"NOT FOR REPLICATION " 
						    	]
						    	[
						        	"( " 
                                    FE::ExpandERwinMacro( "Server_Value" ) 
						        	" ) "
						    	]
					    	}
					    	@else 
					    	
					    	{ 
					        	Pop 
					    	}
				    	>
				    	FE::EndOfStatement				
			    	]
					[
						@if(IsPropertyTrue("Is_Disabled"))
						{
							Set( "var_SQL92Format", "false" )
							[
								PushReference( "Validation_Rule_Ref" )
								[
			    					IsPropertyTrue( "Generate_As_SQL_92_Format" ) 
			    					Set( "var_SQL92Format", "true" )
								]
								Pop
							]
							Equal(Value("var_SQL92Format"),"true") 
							PushOwner
					    	"ALTER TABLE " 
			        				[ FE::OwnerOverride( "true" ) "." ] 
				    				< QuotedName >
		        			Pop
		    				"\n\t" " "
							[
								LookupProperty("Force_Checking_Of_Existing_Data","true"," WITH CHECK ","false"," WITH NOCHECK ")
							]
							" NOCHECK "
							<
								[ 
									FE::Option( "ConstraintName" ) 
						    		[ "CONSTRAINT " QuotedName ] 
								]
							>
							FE::EndOfStatement
						}
					]
				}
			}
		]
		
		/* constraint in alter */
		[
			FE::Option( "ColumnCheckConstraint" )							
			FE::Option( "ColumnConstraintInAlter" )
			FE::Bucket( "94" ) 
			"\n"
			ForEachReference( "Physical_Columns_Order_Ref" )
			{
				ForEachOwnee( "Check_Constraint_Usage" )
				{
				    [
					    PushOwner
					    PushOwner
						    "ALTER TABLE " 
						    
						    [ FE::OwnerOverride( "true" ) "." ] 
						    < QuotedName >
						    
					    Pop
					    Pop
					    "\n\t" 
				        [ 
				            LookupProperty( "Force_Checking_Of_Existing_Data", "true", " WITH CHECK ", "false", " WITH NOCHECK " ) 
				        ]
					    "ADD "
					    [ FE::Option( "ConstraintName" ) 
						    [ "CONSTRAINT " QuotedName ] 
						]
					    <
						    Set( "var_bIsNotForReplication", "false" )
						    [ 
						        IsPropertyTrue( "Is_Not_For_Replication" ) 
						        Set( "var_bIsNotForReplication", "true" ) 
						    ]
						    PushReference( "Validation_Rule_Ref" )
						    [
							    IsPropertyTrue( "Generate_As_SQL_92_Format" )
							    "\n\t\t"  
							    "CHECK  " 
							    [ 
							        Equal( Value( "var_bIsNotForReplication" ) , "true" ) 
							        "NOT FOR REPLICATION "
							    ]
							    [
							        "( " 
                                    FE::ExpandERwinMacro( "Server_Value" ) " ) "
							    ]
						    ]
						    Pop
						    Remove( "var_bIsNotForReplication" )
					    >
					    FE::EndOfStatement
				    ]
				}
			}
		]
							
								
		/*Generate column check constraints */
		[
			FE::Option( "ColumnCheckConstraint" )
			FE::Bucket( "94" ) 
			"\n"
			ForEachReference( "Physical_Columns_Order_Ref" )
			{
				ShouldGenerate
				IsNotInheritedFromUDD
				"exec sp_bindrule "
				<
					ForEachOwnee( "Check_Constraint_Usage" )
					{
						IsNotInheritedFromUDD
						OnceForObject( "Create Check_Constraint_Usage" )
						<
							PushReference( "Validation_Rule_Ref" )
							[ 
							    IsPropertyFalse( "Generate_As_SQL_92_Format" )
		                        					"'"
		                        
					            [ FE::OwnerOverride( "true" ) "." ] 
					            < QuotedName >
		                        
		                        "'"
		                    ]
							Pop
						>
					}
				>
				", " 
				"'"
				[
					PushOwner
					[
						[ FE::OwnerOverride( "true" ) "." ] 
						QuotedName
						"."
					]
					Pop
				]
				QuotedName 
				"'"
				FE::EndOfStatement
			}
		]
	
		/* add column default values - using Alter - if option specified */
		[
			FE::Option( "ColumnDefaultValue" )	
			FE::Option( "ColumnDefaultInAlter" )
			FE::Bucket( "94" )
		    ForEachReference( "Physical_Columns_Order_Ref", "require_one" )
		    {
			    ForEachOwnee( "Default_Constraint_Usage" )
			    {
			        [
				        PushOwner
				        PushOwner
					        "ALTER TABLE " 
				
					        [ FE::OwnerOverride( "true" ) "." ] 
					        < QuotedName >
						    
				        Pop
				        Pop
				        "\n\t" 
				        "ADD CONSTRAINT " 
				        [
				            FE::Option( "ConstraintName" ) 
				            QuotedName
				        ]
				        <
					        PushReference( "Default_Ref" )
					        [
					            IsPropertyTrue( "Generate_As_SQL_92_Format" ) 
					            "\n\t\t" 
					            " DEFAULT  " 
                                FE::ExpandERwinMacro( "Server_Value" )
					        ]
					        Pop
				        >
				        PushOwner
				            " FOR " 
				            QuotedName
				        Pop
                        FE::EndOfStatement
			        ]
			    }
		    }
		]
	
		/*Generate column default values */
		[
			FE::Option( "ColumnDefaultValue" )
			FE::Bucket( "90" ) 
			"\n" 
			
		    ForEachReference( "Physical_Columns_Order_Ref", "require_one" )
		    {
			    ShouldGenerate
			    IsNotInheritedFromUDD
			    "exec sp_bindefault "
			    <
				    ForEachOwnee( "Default_Constraint_Usage" )
				    {
					    IsNotInheritedFromUDD
					    OnceForObject( "Create Default_Constraint_Usage" )
					    <
						    PushReference( "Default_Ref" )
						    [
							    IsPropertyFalse( "Generate_As_SQL_92_Format" )
                                NotEqual( FE::ExpandERwinMacro( "Server_Value" ), "" )
							    "'"

					            [ FE::OwnerOverride( "true" ) "." ] 
					            < QuotedName >

							    "'" 
						    ]
						    Pop
					    >
				    }
			    >
			    ", " 
			    "'"
			    PushOwner
			    [

				    [ FE::OwnerOverride( "true" ) "." ] 
				    QuotedName
					"."
			    ]
			    Pop
			    QuotedName "'"
			    FE::EndOfStatement
		    }
			
		]
	
		[ 
		    Equal( ObjectType, "Default_Constraint_Usage" ) 
		    Pop 
		    Pop 
		]
	
		/*Generate the FK constraint in Alter */
		[
			FE::Option( "FKConstraintInAlter" )
			FE::Bucket( "94" ) 
			"\n"
			ForEachOwnee( "Key_Group" )
			{
				IsPropertyTrue( "Generate_As_Constraint" )
				"ALTER TABLE "
				PushOwner
				    [ FE::OwnerOverride( "true" ) "." ] 
				    QuotedName
				Pop
	            [ 
		            PushReference( "Relationship_Ref" )
	                    [ LookupProperty( "Force_Checking_Of_Existing_Data", "true", " WITH CHECK ", "false", " WITH NOCHECK " ) ]
	                Pop
	            ]
				"\n\t" 
				"ADD "
				< Execute( "Clause: FKConstraint" ) >
				FE::EndOfStatement
			}
		]
		
		/*Generate table-level stored procedures and functions*/
		[
			FE::Bucket( "100" ) 
			"\n"
			
		    ForEachReference( "Stored_Procedures_Ref", "require_one" )
		    {
			    ShouldGenerate
			    Equal( Property( "Type", "no_translate" ), "1" ) /* table - level */
			    [ 
			        FE::Option( "TableDropProcedure" ) 
			        Execute( "Drop Stored_Procedure" )
			    ]
			    [ 
			        FE::Option( "TableCreateProcedure" ) 
			        Execute( "Create Stored_Procedure" )
			    ]
		    }
			
		]
		[
			FE::Bucket( "100" ) 
			"\n"
			
		    ForEachReference( "Functions_Ref", "require_one" )
		    {
			    ShouldGenerate 
			    Equal( Property( "Type", "no_translate" ), "1" ) /* table - level */
			    [
			        FE::Option( "TableDropFunction" ) 
			        Execute( "Drop Function" )
			    ]
			    [
			        FE::Option( "TableCreateFunction" ) 
			        Execute( "Create Function" )
			    ]
		    }			
		]
	
		/*Generate the Table Post Script */
		[
			FE::Option( "TablePostScript" )
			
		    ForEachReference( "Script_Templates_Ref", "require_one" )
		    {
			    ShouldGenerate
			    FE::Bucket( "90" )
			    IsPropertyFalse( "Generate_As_Pre_Script" )
                FE::ExpandERwinMacro( "Template_Code" )
			    FE::EndOfStatement( "true" )
		    }			
		]
	
		/* User-defined triggers.   */
		[ 	
			FE::Option( "GenerateUserDefinedTrigger" )	
			FE::Bucket( "110" )
			ForEachOwnee( "Trigger" )
			{
				[ 
					ShouldGenerate
					Execute( "Create Trigger" )
				]
			}
		]
		/*Emit the ERwin Generated Triggers*/
		[
			FE::Option( "ERwinGeneratedTrigger" )			
			FE::Bucket( "110" ) 
			"\n"
			FE::EmitERwinGeneratedTriggers
		]
	
		[
			FE::IsAlterScriptGeneration
			
		    ForEachReference( "Parent_Relationships_Ref", "require_one" )
		    {
			    PushReference( "Child_Entity_Ref" )
			    [
				    Equal( ObjectType, "View" )
				    IsCreated
				    Execute( "Create View" )
			    ]
			    Pop
		    }
			
		]
	
		[
			FE::IsAlterScriptGeneration
			
		    ForEachReference( "Parent_Relationships_Ref", "require_one" )
		    {
			    PushReference( "Parent_Entity_Ref" )
			    [
				    Equal( ObjectType, "Entity" )
				    Pop
				    [
					    ForEachReference( "Dependent_Objects_Ref", "require_one" )
					    {
						    Equal( ObjectType, "Key_Group" )
						    Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" )
						    [ 
						        @ifnot ( IsCreated )
						        {
						            Execute( "Create Constraint" )
						        }
						    ]
					    }
				    ]
				    PushReference( "Child_Entity_Ref" )
			    ]
			    Pop
		    }
			
		]
		
		/*Generate UDP's and Comments as Extended Properties*/
		[
			FE::Option( "CreateTable" )
			ShouldGenerate
			/* Set the variables required by the "Clause: Specify Extended Properties". */
			Set( "var_Operation", "sp_addextendedproperty" )
			Set( "var_RemoveVariables", "false" ) 
			Set( "var_Comment", "Comment" )
			Set( "var_Level0Type", "SCHEMA" )
			[ 
			    PushReference( "Schema_Ref" ) 
			    Set( "var_Level0Name", Property( "Name" ) ) 
			    Pop 
			]
			Set( "var_Level1Type", "TABLE" )
			Set( "var_Level1Name", Property( "Physical_Name" ) )
			
			/* Generate Table comments and UDPs */
			Execute( "Clause: Specify Extended Properties" )
			
			/* Generate column comments and UDPs */
			Set( "var_Level2Type", "COLUMN" )
			ForEachReference( "Physical_Columns_Order_Ref" )
			{
				Set( "var_ExtendedPropertyValue", Property( "Comment" ) )
				Set( "var_Level2Name", Property( "Physical_Name" ) )
				Execute( "Clause: Specify Extended Properties" )
			}
			
			/* Generate key group comments and UDPs */
			Set( "var_Level2Type", "INDEX" )
			ForEachOwnee( "Key_Group" )
			{
				Set( "var_ExtendedPropertyValue", Property( "Comment" ) )
				Set( "var_Level2Name", Property( "Physical_Name" ) )
				Execute( "Clause: Specify Extended Properties" )
			}
			
			/* Remove the variables. */
		    [ Remove( "var_Operation" )             ]
		    [ Remove( "var_Comment" )               ]
		    [ Remove( "var_RemoveVariables" )       ]
		    [ Remove( "var_ExtendedPropertyName" )  ] 
		    [ Remove( "var_ExtendedPropertyValue" ) ]
		    [ Remove( "var_Level0Type" )            ] 
		    [ Remove( "var_Level0Name" )            ]
		    [ Remove( "var_Level1Type" )            ] 
		    [ Remove( "var_Level1Name" )            ]
		    [ Remove( "var_Level2Type" )            ] 
		    [ Remove( "var_Level2Name" )            ]
		]

		[ 
		    FE::Bucket( "150" ) 
			ForEachOwnee( "Permission" )
			{
				Execute( "Create Permission" )
			}
		]


    ]
]
SPItemEnd

SPItemBegin [keep format] = Create Function
	[
		OnceForObject( "Create Function" )
		FE::Bucket( "100" )
		ShouldGenerate
		
		/* Check if the valid FE Options are selected. */
		Set( "var_bProceed", "false" )
		Switch( Property( "Type" ) )
		{
			Choose( "Model Level" )
			{
				FE::Option( "ModelCreateFunction" )
				Set( "var_bProceed", "true" )
			}
			Choose( "Table Level" )
			{
				FE::Option( "TableCreateFunction" )
				
				/* If 'Generate_As_Pre_Script' Property is true Function is displayed Before Table */
				/* Else Function is displayed After the Table creation.                            */
				/* this is only for Table level functions.                                         */
				@if( IsPropertyTrue( "Generate_As_Pre_Script" ) )
				{
					FE::Bucket( "57" )
				}
				@else
				{
					FE::Bucket( "100" )
				}
				Set( "var_bProceed", "true" )
			}
		}
		Equal( Value( "var_bProceed" ), "true" )
		
        < FE::ExpandERwinMacro( "Template_Code" ) >
		Remove( "var_bProceed" )
		FE::EndOfStatement
		
		/* Generate comments and UDP's as Extended Properties. */
		[
			/* Set the variables required by the "Clause: Specify Extended Properties". */
			Set( "var_RemoveVariables", "true" ) 
			Set( "var_Operation", "sp_addextendedproperty" ) 
			Set( "var_Comment", "Definition" )
			Set( "var_Level0Type", "SCHEMA" )
			[ PushReference( "Schema_Ref" ) Set( "var_Level0Name", Property( "Name" ) ) Pop ]
			Set( "var_Level1Type", "FUNCTION") 
			Set( "var_Level1Name", Property( "Name" ) )
			
			/* Generate Function comments and UDPs */
			Execute( "Clause: Specify Extended Properties" )
		]
		[ 
		    FE::Bucket( "150" ) 
		    ForEachOwnee( "Permission" )
			{
				Execute( "Create Permission" )
			}
		]

	]

SPItemEnd

SPItemBegin [keep format] = Create Key_Group
[
	[
		FE::IsAlterScriptGeneration
		[ Execute( "Create Constraint" ) ]
	]
	[	
		ShouldGenerate
		
		/* Check if the create index option is set for the appropriate type. */
		Set( "var_Proceed", "false" )
		@if ( Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" ) )
		{
			FE::Option( "CreatePKIndex" )
			Set( "var_Proceed", "true" )
			Set( "var_GeneratePKConstraint", "false" )
			
			@if ( Equal( Value( "var_Proceed" ), "true" ) )
			{
			    IsPropertyTrue( "Generate_As_Constraint" )
			    
			    /* Check if PK constraint option is turned on. */
			    
			    [
			        FE::Option( "PKConstraintInCreate" )
			        Set( "var_GeneratePKConstraint", "true" )
			    ]
			    
			    [
			        FE::Option( "PKConstraintInAlter" )
			        Set( "var_GeneratePKConstraint", "true" )
			    ]
			}
			
			/* Suppress Index generation if PK Constraint option is turned on. */
			@if ( Equal( Value( "var_GeneratePKConstraint" ), "true" ) )
			{
			    Set( "var_Proceed", "false" )
			}
			
			Remove( "var_GeneratePKConstraint" )
		}
		@elseif ( Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" ) )
		{
			FE::Option( "CreateAKIndex" )
			Set( "var_Proceed", "true" )
			Set( "var_GenerateAKConstraint", "false" )
			@if ( Equal( Value( "var_Proceed" ), "true" ) )
			{
			    IsPropertyTrue( "Generate_As_Constraint" )
			    
			    /* Check if Unique constraint option is turned on. */
			    
			    [
			        FE::Option( "AKConstraintInCreate" )
			        Set( "var_GenerateAKConstraint", "true" )
			    ]
			    
			    [
			        FE::Option( "AKConstraintInAlter" )
			        Set( "var_GenerateAKConstraint", "true" )
			    ]
			}
			
			/* Suppress Index generation if Unique Constraint option is turned on. */
			@if ( Equal( Value( "var_GenerateAKConstraint" ), "true" ) )
			{
			    Set( "var_Proceed", "false" )
			}
			
			Remove( "var_GenerateAKConstraint" )
			
		}
		@elseif ( Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" ) )
		{
			FE::Option( "CreateFKIndex" )
			Set( "var_Proceed", "true" ) 			
		}
		@else
		{
			FE::Option( "CreateIEIndex" )
			Set( "var_Proceed", "true" )
		}

		@if ( Equal( Value( "var_Proceed" ), "true" ) )
		{
			OnceForObject( "Create Key_Group" )
			
			FE::RecordCreate
			[
				FE::Bucket( "90" )
				"CREATE " 
				
				/* Unique Index */
				[ IsPropertyTrue( "Is_Unique" ) "UNIQUE " ] 
				
				/*Clustered Index */
				[
					Set( "var_bValidOptionSelected", "false" )
					[
						PushOwner
						[
							Switch( ObjectType )
							{
								Choose( "Entity" )
								{
									FE::Option( "IndexClustered" )
									Set( "var_bValidOptionSelected", "true" )
								}
								Choose( "View" )
								{
									FE::Option( "CreateViewIndexClustered" )
									Set( "var_bValidOptionSelected", "true" )
								}
							}
						]
						Pop
						Equal( Value( "var_bValidOptionSelected" ), "true" )
						LookupProperty( "Is_Clustered", "true", "CLUSTERED", "false", "NONCLUSTERED" ) 
						" "
					]
					Remove( "var_bValidOptionSelected" )
				]
				
				"INDEX "
				
				/*Name of the index.*/
				< QuotedName >
				
				" ON "
				PushOwner
				/* Name of the Table or View*/
				
	            [ FE::OwnerOverride( "true" ) "." ] 
		        QuotedName
		        
				Pop
				
				/* Columns */
				"\n( "
				<
					ForEachReference( "Index_Members_Order_Ref" )
					{
						ListSeparator( "," )
						"\n\t"
						Pad( QuotedName, 20 )
						[
						    "  " 
						    Property( "Key_Group_Sort_Order", "no_translate" )
						]
					}
				>
				"\n)"
				
				/* Include Columns */
				[
					"\nINCLUDE( "
					<
						ForEachReference( "SQLServer_Include_Columns_Ref" )
						{
							ListSeparator( "," )
							Property( "Name" )
						}
					>
					" )"
				]
				
				/* Index Options */
				[
					[
						FE::Option( "IndexPhysicalStorage" )
						[
							"\n"	
							"WITH ( " 
							"\n\t"
							<
								Separator( ",\n\t",
									["PAD_INDEX = "					LookupProperty( "SQLServer_Pad_Index", "true", "ON", "false", "OFF" )],
									["FILLFACTOR = " 				< Property( "SQLServer_Fill_Factor" )>],
									["SORT_IN_TEMPDB = "			LookupProperty( "SQLServer_Sort_In_Temp_DB", "true", "ON", "false", "OFF" )],
									["IGNORE_DUP_KEY = "			LookupProperty( "SQLServer_Ignore_Duplicate_Keys", "true", "ON", "false", "OFF" )],
									["STATISTICS_NORECOMPUTE = "	LookupProperty( "SQLServer_Keep_Existing_Statistics", "true", "ON", "false", "OFF" )],
									["DROP_EXISTING = "				LookupProperty( "SQLServer_Drop_Existing_Index", "true", "ON", "false", "OFF" )],
									["ONLINE = "					LookupProperty( "Online", "true", "ON", "false", "OFF" )],
									["ALLOW_ROW_LOCKS = "			LookupProperty( "Allow_Row_Locks", "true", "ON", "false", "OFF" )],
									["ALLOW_PAGE_LOCKS = "			LookupProperty( "Allow_Page_Locks", "true", "ON", "false", "OFF" )],
									["MAXDOP = "					< Property( "SQLServer_Max_Parallel" )>]
								)
							>
							"\n"	
							"     )"
						]
					]
					/*Specify the partition scheme or filegroup on which the table is stored.*/
					[
						FE::Option("IndexPartitions")
						[
							"\n"	
							"ON " 
							<
								[
									PushReference( "SQLServer_Partition_Scheme_Ref" )
									< Property( "Name" ) > 
									Pop
									"( "
									ForEachReference( "Partition_Columns_Ref" )
									{
										ListSeparator( "," )
										< Property( "Name" ) >
									}
									" )"
								]
								[ 
							    	PushReference( "SQLServer_File_Group_Ref" ) 
							    	"\"" 
							    	< Property( "Name" ) > 
							    	"\"" 
							    	Pop
								]
							>
						]
					]
				]
                FE::EndOfStatement
			]
		}
		Remove( "var_Proceed" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Permission
[ 
	FE::Option( "OtherOptionsPrivilege" ) 
	FE::Bucket( "150" )

    	/* Are we granting or revoking the privileges? */
	PushOwner
	Set( "Permissions", "" )
	@if(Equal(ObjectType,"Model"))
	{	Pop
		@if ( IsPropertyNotNull( "SQLServer_Server_Permissions" ) )
		{	
			Set( "Permissions","SQLServer_Server_Permissions" )
			Set( "var_bServerObject", "true" )
		}
	}
	@elseif (Equal(ObjectType,"SQLServer_Login" ))
	{   Pop
		Set( "Permissions", "SQLServer_Login_Permissions" )
		Set( "var_bServerObject", "true" )
	}
	@else
	{ 
		Pop
		/*Specify the ObjectType On Which privilege is given*/
		" "
		PushOwner
		Switch( ObjectType )
		{
			Choose( "Domain" )
			{
				Set( "Permissions", "SQLServer_Type_Permissions" )
			}
			Choose( "Entity" )
			{
				Set( "Permissions", "SQLServer_Table_Permissions" )
			}
			Choose( "Function" )
			{
				Set( "Permissions", "SQLServer_Function_Permissions" )
			}
			Choose( "Synonym" )
			{
				Set( "Permissions", "SQLServer_Synonym_Permissions" )
			}
			Choose( "Stored_Procedure" )
			{
				Set( "Permissions", "SQLServer_Stored_Procedure_Permissions" )
			}
			Choose( "View" )
			{
				Set( "Permissions", "SQLServer_View_Permissions" )
			}
			Choose( "Schema" )
			{
				Set( "Permissions", "SQLServer_Schema_Permissions" )
			}
			Choose( "SQLServer_Application_Role")
			{
				Set( "Permissions", "SQLServer_Application_Role_Permissions" )
			}
			Choose( "SQLServer_Assembly")
			{
				Set( "Permissions", "SQLServer_Assembly_Permissions" )
			}
			Choose( "SQLServer_Database" )
			{
				Set( "Permissions", "SQLServer_Database_Permissions" )
			}
			Choose( "SQLServer_Database_Role" )
			{
				Set( "Permissions", "SQLServer_Database_Role_Permissions" )
			}
			Choose( "SQLServer_Fulltext_Catalog" )
			{
				Set( "Permissions", "SQLServer_Fulltext_Catalog_Permissions" )
			}
			Choose( "SQLServer_Symmetric_Key" )
			{
				Set( "Permissions", "SQLServer_Symmetric_Key_Permissions" )
			}
			Choose( "SQLServer_XML_Schema_Collection" )
			{
				Set( "Permissions", "SQLServer_XML_Schema_Collection_Permissions" )
			}
			Choose( "User_Id" )
			{
				Set( "Permissions", "SQLServer_User_Id_Permissions" )
			}
			Choose("SQLServer_Certificate" )
			{
				Set( "Permissions", "SQLServer_Certificate_Permissions" )
				Equal (Left([ Execute( "Is Server Object" )], "2" ), "SO")
				Set( "var_bServerObject", "true" )
			}
			Choose("SQLServer_Asymmetric_Key" )
			{
				Set( "Permissions", "SQLServer_Asymmetric_Key_Permissions" )
				Equal (Left([ Execute( "Is Server Object" )], "2" ), "SO")
				Set( "var_bServerObject", "true" )
			}
		}
		Pop
	}
	[
	    Equal( Value( "var_bServerObject" ), "true" ) 
	    "EXEC ('" 
	    "USE master;" 
	]
	"\n"
	/* Store the privilege type in a variable */
	Set( "var_PrivilegeType", Property( "Type" ) )
			
	/*Specify the type of privilege */
	"\n"
	UpperCase( Value( "var_PrivilegeType" ) )
	" "
	/* Check if the ability to grant the specified permission is to be revoked. */
	[
		Equal( Property( "Type" ), "Revoke" ) 
		IsPropertyTrue( "Can_Grant_Permission" ) 
		"\n" 
		"GRANT OPTION FOR " 
	]
	/* Specify Permissions to be granted on the securable*/
	<@if ( Equal( [ Property( Value( "Permissions" ) ) ], "All" ) )
	{
		"ALL PRIVILEGES"
	}
	@else
	{
		<UpperCase( FormatProperty( <Value( "Permissions" )> ) )>
	}>
	"\n"
	[ 
		PushOwner 
			Set( "var_SecurableType", ObjectType )
			Set( "var_SecurableName", Property( "Name" ) ) 
		Pop 
	]
	@ifnot(Equal(Value("var_SecurableType"),"Model"))
	{
		@if ( IsMatch( Value( "var_SecurableType" ), "Entity", "View", "Stored_Procedure", 
						"Synonym","Function" ) )
		{
			"ON OBJECT :: " PushOwner
			[ FE::OwnerOverride( "true" ) "." ]
				QuotedName
				Pop
				[
					"( "
					< FormatProperty( "Columns_Ref", "p:Name", "d:, " ) > 
					" )"
				]
		}
		@elseif ( Equal(Value( "var_SecurableType" ), "Schema" ) )
		{
			"ON SCHEMA :: " 
			[ FE::Option( "QuoteName" )"\"" ]
			Value( "var_SecurableName" )
			[ FE::Option( "QuoteName" )"\"" ]
		}
		@elseif ( Equal(Value( "var_SecurableType" ), "SQLServer_Database_Role" ) )
		{
			"ON ROLE :: " 
			[ FE::Option( "QuoteName" )"\"" ]
			Value( "var_SecurableName" )
			[ FE::Option( "QuoteName" )"\"" ]
		} 
		@elseif ( Equal(Value( "var_SecurableType" ), "Domain" ) )
		{
			"ON TYPE :: "
			[ FE::Option( "QuoteName" )"\"" ]
			Value( "var_SecurableName" )
			[ FE::Option( "QuoteName" )"\"" ]
		}
		@elseif ( Equal(Value( "var_SecurableType" ), "User_Id" ) )
		{
			"ON USER :: "
			[ FE::Option( "QuoteName" )"\"" ]
			Value( "var_SecurableName" )
			[ FE::Option( "QuoteName" )"\"" ]
		}
		@elseif ( Equal(Value( "var_SecurableType" ), "SQLServer_Login" ) )
		{
			"ON LOGIN :: "
			[ FE::Option( "QuoteName" )"\"" ]
			Value( "var_SecurableName" )
			[ FE::Option( "QuoteName" )"\"" ]
		}
		@else
		{
			/* Extract the string 'SQLServer ' (10 characters) from the objectType */
			"ON "
			Set( "var_Value",UpperCase( Mid( Value( "var_SecurableType" ), 10, 100 ) ) )
			Substitute( Value("var_Value"), " ", "_")
			" :: "
			[ FE::Option( "QuoteName" )"\"" ]
			Value( "var_SecurableName" )
			[ FE::Option( "QuoteName" )"\"" ]
		}
	}
	"\n"
	"TO "
	[ FormatProperty( "To_Principals_Ref", "p:Name" ) ]
	
	/* If the objecttype is login, specify the login to 
	which the permission is being granted */
	[ FormatProperty( "SQLServer_Logins_Ref", "p:Name" ) ]
	
	[
		@if ( Equal( Property( "Type" ), "Grant" ) )
		{
			/*Indicate if the grantee will also have the ability to 
			grant the specified permission to other principals. */
			
			IsPropertyTrue( "Can_Grant_Permission" ) 
			"\n" 
			"WITH GRANT OPTION" 
		}
		@else
		{
			/* Indicate if the permission is denied to the specified principal and
			to all other principals to which the principal granted the permission. */
			
			IsPropertyTrue( "SQLServer_Cascade" ) 
			"\n" 
			"CASCADE" 
		}
	]
	[
	    "\n" "AS " 
	    < 
		    PushReference( "Grant_As_Principal_Ref" ) 
		        Property( "Name" ) 
		    Pop 
		>
	]
			
	[ 
	    Equal( Value( "var_bServerObject" ), "true" ) 
	    ";\n')" 
	] /* close EXEC */
	Remove( "var_bServerObject" )
	Remove( "var_PrivilegeType" )
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Referenced Object
[ 
    FE::IsSchemaGeneration 
    Execute( "Create " ObjectType ) 
]
[ 
    FE::IsAlterScriptGeneration 
    IsCreated 
    Execute( "Create " ObjectType ) 
]
SPItemEnd

SPItemBegin [keep format] = Create Role_Usage
[
	ShouldGenerate
    	OnceForObject("CreateRoleUsage")
	FE::Bucket("56")
	PushOwner
	[
		IsMatch(ObjectType,"User_Id","SQLServer_Database_Role")
		[
			Pop
			"sp_addrolemember '" 
			PushReference("Role_Ref") 
			Property( "Name" ) 
			Pop
			"'," 
			" '" 
			PushOwner Property("Name") Pop
			"'"
			FE::EndOfStatement
		]
	]
	[
		Equal(ObjectType,"SQLServer_Login")
		[
			Pop
			"sp_addsrvrolemember '" 
			PushOwner Property("Name") Pop
			"'," 
			" '" 
			PushReference("Role_Ref") 
			Property( "Name" ) 
			Pop
			"'"
			FE::EndOfStatement
		]
	]
]
	
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Aggregate
[
	FE::Option( "CreateAggregate" )
	ShouldGenerate
	FE::Bucket( "66" )
	"CREATE AGGREGATE "
	
	/* Name of the aggregate function. */
    [ FE::OwnerOverride( "true" ) "." ] 
    < QuotedName >
	
	/* Specify the system/user-defined type used to hold the input value. */
	"( "
	< Property( "Input_Parameter_Name" ) >
	" "
	@if ( IsPropertyNull( "Input_Data_Type" ) )
	{
		PushReference( "Input_Type_Ref" )
			@if ( IsPropertyTrue( "Generate_As_User_Defined_Type" ) )
			{
				[ FE::OwnerOverride( "true" ) "." ]
			}
			QuotedName
		Pop
	}
	@else
	{
	    Property( "Input_Data_Type" )
	}
	")"
	
	/* Specify the system/user-defined type used to hold the return value. */
	"\n" 
	"RETURNS "
	@if ( IsPropertyNull( "Return_Data_Type" ) )
	{
		PushReference( "Return_Type_Ref" )
			@if ( IsPropertyTrue( "Generate_As_User_Defined_Type" ) )
			{
				[ FE::OwnerOverride( "true" ) "." ]
			}
			QuotedName
		Pop
	}
	@else
	{
	    Property( "Return_Data_Type" )
	}
	
	/*Specify the assembly to bind with the user-defined aggregate function. */
	"\n" 
	"EXTERNAL NAME "
	<
		PushReference( "Assembly_Ref" )
			"[" 
			QuotedName 
			"]"
		Pop
	>
	[ 
	    "." 
	    "[" 
	    < Property( "Class_Name" ) > 
	    "]" 
	]
	
	FE::EndOfStatement
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" )
		[ 
		    PushReference( "Schema_Ref" ) 
		        Set( "var_Level0Name", Property( "Name" ) ) 
		    Pop 
		]
		Set( "var_Level1Type", "AGGREGATE" ) 
		Set( "var_Level1Name", Property( "Name" ) )
		
		/* Generate Aggregate comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Application_Role
[	
	FE::Option( "CreateApplicationRole" )
	ShouldGenerate
	OnceForObject( "CreateApplicationRole" )
	FE::RecordCreate
	
	/* Store the name of the database role */
	Set( "var_RoleName", < QuotedName > )
	
	/* App role can reference schema */
	[ 
	    PushReference( "Default_Schema_Ref" ) 
	    [ 
	        Execute( "Create Referenced Object" ) 
	    ] 
	    Pop 
	]
	
	FE::Bucket( "55" )
	
	"CREATE APPLICATION ROLE "
	
	/* Specify the name of the role.*/
	Value( "var_RoleName" )
	
	/*Specify the password that database users will use to activate the application role.*/
	"\n"
	"WITH PASSWORD = " 
	[ 
	    FE::Option( "OtherOptionsPassword" ) 
	    "'" 
	    FE::Password 
	    "'" 
	]
	
	/* Specify the first schema that will be searched by the server when 
		it resolves the names of objects for this role.*/
	[
	    PushReference( "Default_Schema_Ref" ) 
	        ",\n" 
	        "DEFAULT_SCHEMA = " 
	        < QuotedName > 
	    Pop
	]
	
	FE::EndOfStatement
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "USER" ) 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Schema comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]

	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
	
	Remove( "var_RoleName" )
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Assembly
[
	FE::Option( "CreateAssembly")
	ShouldGenerate
	OnceForObject( "CreateAssembly")

	/* Assembly can reference users/roles. */
	[ 
	    PushReference( "Authorization_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	
	FE::Bucket( "55" )
	"CREATE ASSEMBLY " 

	/* Name of the Assembly */
	< QuotedName >
	
	/* Name of a user or role as owner of the assembly. */
	[
	    PushReference( "Authorization_Ref" ) 
	    [
	        "\n" 
	        "AUTHORIZATION " 
	        < QuotedName > 
	    ] 
	    Pop
	]
	
	/* 
		Local path or network location where the 
		assembly that is being uploaded is located. 
	*/

	"\n" 
	"FROM" 
	"\n"
	<
		/* SqlServer2005 does not allow multiple files to be specified during
		the assembly create statement. Therefore, only the first file from the
		"Files_Ref" is added with the create statement, and the rest are added
		using the Alter syntax. */
		
		Set( "var_FirstRefOnly", 0 )	
		ForEachReference( "Source_Files_Ref" )
		{
			@if ( Equal( Value( "var_FirstRefOnly" ), 0 ) )
			{
				Set( "var_FirstRefOnly", 1 )
				"'"
				Property( "Name" )
				"'"
			}
		}
		Remove( "var_FirstRefOnly" )
	>

	/* 
		Code access permissions that are granted 
		to the assembly when it is accessed by SQL Server.
	*/
	[
		"\n" 
		"WITH PERMISSION_SET = " 
		<
			@if ( Equal( Property( "Permission_Set_Type" ), "External Access" ) )
			{ 
			    "EXTERNAL_ACCESS" 
			}
			@else
			{ 
			    UpperCase( Property( "Permission_Set_Type" ) ) 
			}
		>
	]
	
	FE::EndOfStatement
	
	[
		/* SqlServer2005 does not allow multiple files to be specified during
		the assembly create statement. Therefore, only the first file from the
		"Files_Ref" is added with the create statement, and the rest are added
		using the Alter syntax. */

        "ALTER ASSEMBLY "
        < QuotedName >
	    "\n" 
	    "ADD FILE FROM" 
	    "\n"            
		<
			Set( "var_SkipFirstRef", 0 )	
			ForEachReference( "Source_Files_Ref" )
			{
				@if ( Equal( Value( "var_SkipFirstRef" ), 0 ) )
				{
					Set( "var_SkipFirstRef", 1)
				}
				@else
				{
					ListSeparator( ",\n" )
					"'"
					Property( "Name" )
					"'"
				}
			}
			Remove( "var_SkipFirstRef" )
		>
        
        FE::EndOfStatement
	]
	
    [
        "ALTER ASSEMBLY "
        < QuotedName >
	                
        <
            [
                "\n" 
                "WITH" 
                "\n"
                <
					Separator
					(
					    ",\n",
	                    /* Check if the visibility option was modified.*/
	                    [ 
	                        "VISIBILITY = " 
	                        < LookupProperty( "Allow_Use_By_Functions", "true", "ON", "false", "OFF" ) > 
	                    ],
                    	
	                    /* the unchecked data option is included in the command if set to true */
	                    [ 
	                        IsPropertyTrue( "Unchecked_Data") 
	                        "UNCHECKED DATA" 
	                    ]
                    )
                >
            ]
        >
        
        FE::EndOfStatement
    ]
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "ASSEMBLY") 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Assembly comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]

	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
	
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Asymmetric_Key
[
	[
		Equal( Left( [ Execute( "Is Server Object" ) ], "2" ), "SO" )
		SetLocalFlag( "var_bServerObject" )
	]

	Set( "var_bProceed" , "false" )
	
	@if ( IsLocalFlagSet( "var_bServerObject" ) )
	{
		FE::Option( "CreateLogin" )
		Set( "var_bProceed" , "true" )
	}
	@else
	{
		FE::Option( "CreateAsymmetricKey" )
		Set( "var_bProceed" , "true" )				
	}

	Equal( Value( "var_bProceed" ) , "true" )
	
	Remove( "var_bProceed" )
	
		
	ShouldGenerate
	OnceForObject( "CreateAsymmetricKey" )
	
	/* Asymm key can reference users/roles/assembly */
	[ 
	    PushReference( "Authorization_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]		
	[ 
	    PushReference( "Assembly_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	
	FE::Bucket( "55" )
	
	[ 
	    IsLocalFlagSet( "var_bServerObject" ) 
	    "EXEC ('" 
	    "USE master; \n" 
	]
			
	"CREATE ASYMMETRIC KEY " 
	< QuotedName >
	
	/*Specify the owner of the asymmetric key. */
	[
	    "\n" 
	    "AUTHORIZATION " 
	    < Property( "Authorization_Ref" ) >
	]

	<
		/* Specify the source from which to load the asymmetric key pair.*/
		@if ( IsPropertyNull( "Algorithm_Type" ) )
		{
			[
				"\n"  
				"FROM "
				<
					Set( "var_KeySourceType", Property( "Key_Source_Type" ) )
					Switch( Value( "var_KeySourceType" ) )
					{
						Choose( "Assembly" )
						{
							"ASSEMBLY " 
							< 
							    PushReference( "Assembly_Ref" ) 
							        QuotedName 
							    Pop 
							>
						}
						Choose( "Executable" )
						{
							"EXECUTABLE FILE = '" 
							[
							    IsLocalFlagSet( "var_bServerObject" ) 
							    "'"
							]
							< 
							    PushReference( "File_Ref" ) 
							        Property( "Name" ) 
							    Pop 
							>
							"'" 
							[
							    IsLocalFlagSet( "var_bServerObject" ) 
							    "'"
							]
						}
						Choose( "File" )
						{
							"FILE = '" 
							[
							    IsLocalFlagSet( "var_bServerObject" ) 
							    "'"
							]
							< 
							    PushReference( "File_Ref" ) 
							        Property( "Name" ) 
							    Pop 
							>
							"'" 
							[
							    IsLocalFlagSet( "var_bServerObject" ) 
							    "'"
							]
						}
					}
					Remove( "var_KeySourceType" )
				>
			]
		}
		@else
		{
			[
				"\n"  
				"WITH ALGORITHM = " 
				<
					Set( "var_Algorithm", Property( "Algorithm_Type" ) )
					Switch( Value( "var_Algorithm" ) )
					{
						Choose( "512-bit RSA" )
						{
							"RSA_512"
						}
						Choose( "1024-bit RSA" )
						{
							"RSA_1024"
						}
						Choose( "2048-bit RSA" )
						{
							"RSA_2048"
						}
					}
					Remove( "var_Algorithm" )
				>
			]
		}
	>
	
	/* Specify the password with which to encrypt the private key. */
	"\n"
	@if ( FE::Option( "OtherOptionsPassword" ) )
	{
		"ENCRYPTION BY PASSWORD = "
		"'" 
		[
		    IsLocalFlagSet( "var_bServerObject" ) 
		    "'"
		] 
		FE::EncryptionPassword 
		"'" 
		[
		    IsLocalFlagSet( "var_bServerObject" ) 
		    "'"
		]
	}
	@else
	{
		"/* ENCRYPTION BY PASSWORD = */"
	}

	[ 
	    IsLocalFlagSet( "var_bServerObject" ) 
	    ";\n')" 
	] /* close EXEC */

	FE::EndOfStatement
	
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Certificate
[
	[
		Equal
		( 
		    Left( [ Execute( "Is Server Object" ) ], "2" ), 
		    "SO"
		)
		SetLocalFlag( "var_bServerObject" )
	]

	Set( "var_bProceed" , "false" )
	
	@if ( IsLocalFlagSet( "var_bServerObject"  ) )
	{
		FE::Option( "CreateLogin" )
		Set( "var_bProceed" , "true" )
	}
	@else
	{
		FE::Option( "CreateCertificate" )
		Set( "var_bProceed" , "true" )				
	}

	Equal( Value( "var_bProceed" ) , "true" )
	
	Remove( "var_bProceed" )

	ShouldGenerate
	OnceForObject( "CreateCertificate" )
	
	/* Certificate can reference user (via authorization)/assembly. */
	[ 
	    PushReference( "Authorization_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	[ 
	    PushReference( "Assembly_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	
	FE::Bucket( "55" )
	
	[ 
	    IsLocalFlagSet( "var_bServerObject" ) 
	    "EXEC ('" 
	    "USE master; \n" 
	]
	
	"CREATE CERTIFICATE "
	/* Name of the certificate.*/
	 < QuotedName >
	 
	 /*Specify the name of the user that will own this certificate. */
	[
	    "\n" 
	    "AUTHORIZATION " 
	    < Property( "Authorization_Ref" ) >
	]
	
	 
	<
		[
			"\n\t"
			@if ( FE::Option( "OtherOptionsPassword" ) )
			{
				"ENCRYPTION BY PASSWORD = "
				[ 
				    IsLocalFlagSet( "var_bServerObject" ) 
				    "'" 
				] 
				"'" 
				FE::EncryptionPassword 
				"'" 
				[
				    IsLocalFlagSet( "var_bServerObject" ) 
				    "'"
				]
			}
			@else
			{
				"/* ENCRYPTION BY PASSWORD = */"
			}
			"\n\t" 
			"WITH SUBJECT = '" 
			[
			    IsLocalFlagSet( "var_bServerObject" ) 
			    "'"
			] 
			< Property( "Certificate_Subject" ) > 
			"'" 
			[
			    IsLocalFlagSet( "var_bServerObject" ) 
			    "'"
			]
			[ 
			    ",\n\t" 
			    "START_DATE = '" 
			    [
			        IsLocalFlagSet( "var_bServerObject" ) 
			        "'"
			    ] 
			    < Property( "Start_Date" ) > 
			    "'" 
			    [
			        IsLocalFlagSet( "var_bServerObject" ) 
			        "'"
			    ] 
			]
			[ 
			    ",\n\t" 
			    "EXPIRY_DATE = '" 
			    [
			        IsLocalFlagSet( "var_bServerObject" ) 
			        "'"
			    ] 
			    < Property( "Expiration_Date" ) > 
			    "'" 
			    [
			        IsLocalFlagSet( "var_bServerObject" ) 
			        "'"
			    ] 
			]
		]
		
		[
			/*Specify a signed assembly already loaded into the database. */
			[
				"\n\t" 
				"FROM ASSEMBLY " 
				<
				    PushReference( "Assembly_Ref" ) 
				        QuotedName 
				    Pop
				>
			]
			
			/* Specify the path to a file containing a certificate.*/
			[
				"\n"\t 
				"FROM EXECUTABLE FILE = '" 
				[
				    IsLocalFlagSet( "var_bServerObject" ) 
				    "'"
				]
				< Property( "Executable_File_Ref" ) >
				"'" 
				[
				    IsLocalFlagSet( "var_bServerObject" ) 
				    "'"
				]
				[
					"\n\t" 
					"WITH PRIVATE KEY (FILE = '" 
					[IsLocalFlagSet( "var_bServerObject" ) "'"]
					<
					    PushReference( "Private_Key_File_Ref" ) 
					        Property( "Name" ) 
					    Pop
					>
					[IsLocalFlagSet( "var_bServerObject" ) "'"] 
					"')"
				]
			]
		]

	>
	
	[
		"\n\t" 
		"ACTIVE FOR BEGIN_DIALOG = " 
		< LookupProperty( "Is_Active_For_Begin_Dialog", "true", "ON", "false", "OFF" ) >
	]
	
	[ /* close EXEC */
	    IsLocalFlagSet( "var_bServerObject" ) 
	    ";\n')" 
	] 

	
	FE::EndOfStatement
	
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Credential
[	 
	FE::Option( "CreateCredential" )
	FE::Bucket( "54" )
	ShouldGenerate
	
	"CREATE CREDENTIAL " 
	
	/* Specify the name of the credential. */
	< QuotedName >
	
	/* Specify the name of the account to be used when connecting outside the server.*/
	" WITH IDENTITY = '" 
	< Property( "Identity" ) > 
	"'"
	
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Database
[
	FE::Option( "CreateDatabase" )
	ShouldGenerate
	
	Set( "var_BucketNum", "50" )
	@if ( Equal( Property( "Database_Type" ), "Snapshot" ) ) 
	{ 
	    Set( "var_BucketNum", "51" ) 
	}
	
	FE::Bucket( Value( "var_BucketNum") )
	
	"CREATE DATABASE "
	
	/* Name of the database. */
	< QuotedName >
	
	Separator
	(
	    ",\n",
		/* Specify the disk files used to store the data sections of the database. */
		[
			"\n"
			<
				ForEachOwnee("SQLServer_Filegroup" )
				{
					IsPropertyTrue( "Is_Primary")
					ListSeparator(  ",\n")
					"ON " 
					[
					    NotEqual
					    ( 
					        [ 
					        PushOwner 
					            Property( "Database_Type" ) 
					        Pop
					        ], 
					        "Snapshot"
					    ) 
					    "PRIMARY"
					] 
					"\n"
					<
						ForEachOwnee( "SQLServer_Physical_File" )
						{
							ListSeparator(  ",\n")
							Execute( "Clause: Physical File Properties" )
						}
					>
				}
			>
		],
		
		[
			"\n"
			<
				ForEachOwnee("SQLServer_Filegroup" )
				{
					IsPropertyNotEqual( "Is_Primary", "true", "true" )
					ListSeparator(  ",\n")
					"FILEGROUP " 
					QuotedName
					[
					    IsPropertyTrue( "Is_Default" ) 
					    " DEFAULT "
					]
					"\n"
					<
						ForEachOwnee( "SQLServer_Physical_File" )
						{
							ListSeparator(  ",\n")
							Execute( "Clause: Physical File Properties" )
						}
					>
				}
			>
		]
	)
	
	/* If the database is a snapshot, provide details about referenced database. */
	[
		Equal( Property( "Database_Type" ), "Snapshot" )
		"\n" 
		"AS SNAPSHOT OF " 
		[
		    PushReference( "SQLServer_Database_Ref" ) 
		        QuotedName 
		    Pop
		]
	]	
	
	/* Specify the disk files used to store the database log. */
	[
		"\n" 
		"LOG ON " 
		"\n"
		<
			ForEachOwnee( "SQLServer_Physical_File" )
			{
				[
					ListSeparator(  ",\n")
					IsMatch(Property( "Type" ), "Log", "no_case" )
					< Execute( "Clause: Physical File Properties" ) >
				]
			}
		>
	]
	
	/* Specify the default collation for the database. */
	[ 
	    "\n" 
	    "COLLATE " 
	    < Property( "Collation_Name" ) > 
	]
	
	/* Specify the DB_Chaining and Trustworthy options. */
	[ 
		"\n" 
		"WITH "
		<
			[
			    IsPropertyTrue( "Allow_Trustworthy_Modules") 
			    "TRUSTWORTHY ON"
			]
			[
			    IsPropertyTrue( "Can_Chain" ) 
			    [
			        IsPropertyTrue( "Allow_Trustworthy_Modules") 
			        ", "
			    ]
			    "DB_CHAINING ON"
			]
		>
	]
	FE::EndOfStatement
	
	/* Change the attributes of the database. 
	   Since all database options do not use the WITH  clause or 
	   can be specified in combination with other options, 
	   they are grouped according to the syntax requirements.
	*/
	[
	    NotEqual( Property( "Database_Type" ), "Snapshot" )
		[
			"ALTER DATABASE "
			< QuotedName >
			
			"\n" 
			"SET" 
			"\n"
			<
		    	Separator
		    	(  
		        	",\n",
	        	
	            	/* State Option */
	            	[ LookupProperty( "State_Type", "0", "ONLINE", "5", "EMERGENCY", "6", "OFFLINE") ],
		
	            	/* User access option */
	            	[ LookupProperty( "Restricted_Access_Type", "0", "MULTI_USER ", "1", "SINGLE_USER ", "2", "RESTRICTED_USER" ) ],
	
	            	/* Update Option */
	            	[ LookupProperty( "Is_Read_Only", "true", "READ_ONLY", "false", "READ_WRITE") ],
	            	
	            	/* Parameterization Option */
	            	[ "PARAMETERIZATION " LookupProperty( "Parameterization", "0", "SIMPLE", "1", "FORCED") ],
	            	
	            	/*Data Correlation Optimization option*/
	            	[ "DATE_CORRELATION_OPTIMIZATION " LookupProperty( "Is_Data_Correlation_Optimization_Active", "true", "ON", "false", "OFF" ) ]
			            	
				)
			>
			
			/* Specify the termination option */
			[
				"\n WITH " 
				LookupProperty( "Termination_Option", "0", "ROLLBACK AFTER ", "1", "ROLLBACK IMMEDIATE", "2", "NO_WAIT" ) 
				[
			    	Equal( Property( "Termination_Option", "no_translate" ), "0" ) 
			    	Property( "Termination_Wait_Time" )
				]
			]
			FE::EndOfStatement
		]
		
		[
			"ALTER DATABASE "
			< QuotedName >
			"\n"
			"SET "
			"\n"\t
			<
				Separator
				(
			    	",\n",
					/* Cursor Options */
					[LookupProperty( "Close_Cursor_On_Commit", "true", "CURSOR_CLOSE_ON_COMMIT ON", "false", "CURSOR_CLOSE_ON_COMMIT OFF")],
					["CURSOR_DEFAULT " LookupProperty( "Cursor_Default_Type", "0", "GLOBAL", "1", "LOCAL")],
					/* Automatic Options */
					[LookupProperty( "Auto_Close", "true", "AUTO_CLOSE ON", "false", "AUTO_CLOSE OFF")],
					[LookupProperty( "Auto_Create_Statistics", "true", "AUTO_CREATE_STATISTICS ON", "false", "AUTO_CREATE_STATISTICS OFF")],
					[LookupProperty( "Auto_Shrink", "true", "AUTO_SHRINK ON", "false", "AUTO_SHRINK OFF")],
					[LookupProperty( "Auto_Update_Statistics", "true", "AUTO_UPDATE_STATISTICS ON", "false", "AUTO_UPDATE_STATISTICS OFF")],
					[LookupProperty( "Auto_Update_Statistics_Async", "true", "AUTO_UPDATE_STATISTICS_ASYNC ON", "false", "AUTO_UPDATE_STATISTICS_ASYNC OFF")],
					/* SQL Options */
					[LookupProperty( "Is_Null_Default", "true", "ANSI_NULL_DEFAULT ON", "false", "ANSI_NULL_DEFAULT OFF")],
					[LookupProperty( "Use_Ansi_Nulls", "true", "ANSI_NULLS ON", "false", "ANSI_NULLS OFF")],
					[LookupProperty( "Are_Strings_Padded", "true", "ANSI_PADDING ON", "false", "ANSI_PADDING OFF")],
					[LookupProperty( "Are_Warnings_Issued", "true", "ANSI_WARNINGS ON", "false", "ANSI_WARNINGS OFF")],
					[LookupProperty( "Abort_On_Arithmetic_Error", "true", "ARITHABORT ON", "false", "ARITHABORT OFF")],
					[LookupProperty( "Yield_Null_On_Null_Concatenation", "true", "CONCAT_NULL_YIELDS_NULL ON", "false", "CONCAT_NULL_YIELDS_NULL OFF")],
					[LookupProperty( "Abort_On_Precision_Loss", "true", "NUMERIC_ROUNDABORT ON", "false", "NUMERIC_ROUNDABORT OFF")],
					[LookupProperty( "Is_Quoted_Identifier", "true", "QUOTED_IDENTIFIER ON", "false", "QUOTED_IDENTIFIER OFF")],
					[LookupProperty( "Allow_Recursive_Triggers", "true", "RECURSIVE_TRIGGERS ON", "false", "RECURSIVE_TRIGGERS OFF")],
					/* This property is not in the metadata yet, uncomment this after the
					metadata has been updated.*/
					/*Comment: Recovery Options */
					[
				    	"RECOVERY "  
				    	LookupProperty( "Recovery_Type", "0", "FULL", "1", "BULK_LOGGED", "2", "SIMPLE") 
					],
					[LookupProperty( "Use_Torn_Page_Detection", "true", "TORN_PAGE_DETECTION ON", "false", "TORN_PAGE_DETECTION OFF") ],
					/* This property is not in the metadata yet, uncomment this after the
					metadata has been updated.*/
					[
				    	"PAGE_VERIFY " 
				    	LookupProperty( "Page_Verify", "0", "NONE", "1", "TORN_PAGE_DETECTION", "2", "CHECKSUM") 
					]
				)
			>
			FE::EndOfStatement
		]
		[
			ForEachOwnee("SQLServer_Filegroup")
			{
				"ALTER DATABASE "
				PushOwner < QuotedName > Pop
				"\n"
				" MODIFY FILEGROUP "
				Property("Name")
				< LookupProperty("Is_Read_Write","0"," ReadWrite ","1"," ReadOnly ","") >
				FE::EndOfStatement			
			}	
		]
		/* Set the database compatibility level. */
		[
			"sp_dbcmptlevel " 
			< QuotedName >
			", '" 
			Switch( Property( "Compatibility_Level_Type" ) )
			{
				Choose( "SQL Server 2005" ){ "90" }
				Choose( "SQL Server 2000" ){ "80" }
				Choose( "SQL Server 7.0" ) { "70" }
			}
			"'"
			FE::EndOfStatement
		]
		
		/* Generate comments and UDP's as Extended Properties. */
		[ Execute( "Clause: Specify Database Extended Properties" ) ]
	
		[ 
	    	FE::Bucket( "150" ) 
	    	ForEachOwnee( "Permission" )
			{
				Execute( "Create Permission" )
			}
		]
	]
	Remove( "var_BucketNum")
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Database_Role
[
	FE::Option( "CreateDatabaseRole" )
	ShouldGenerate
	OnceForObject( "CreateDatabaseRole" )
	FE::RecordCreate
	
	/* role can reference user */
	[ 
	    PushReference( "Authorization_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	
	/* Store the name of the database role */
	Set( "var_RoleName", < QuotedName > )

	FE::Bucket( "55" )
	
	"CREATE ROLE " 
	
	/* Specify the name of the role.*/
	Value( "var_RoleName" )

	/* Specify the database user or role that is to own the new role.*/
	[
	    "\n" 
	    "AUTHORIZATION " 
	    <
	        PushReference( "Authorization_Ref" ) 
	            Property( "Name" ) 
	        Pop
	    > 
	]
	
	FE::EndOfStatement

	/* Add the role as a member of another role. */
	Set( "var_RoleName", Property( "Name" ) )
	[
		ForEachOwnee( "Role_Usage" )
		{
			< Execute("Create Role_Usage") >
		}
	]
	Remove( "var_RoleName" )
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "USER" ) 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Schema comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
	
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Filegroup
[
	OnceForObject( "Create SQLServer_Filegroup" )
	FE::RecordCreate
	"ALTER DATABASE " 
	PushOwner 
	QuotedName
	Pop
	
	" ADD FILEGROUP "
	QuotedName
	FE::EndOfStatement
	ForEachOwnee("SQLServer_Physical_File")
	{
		@if(IsCreated)
		{
			Execute("Create SQLServer_Physical_File")
		}
	}
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Fulltext_Catalog
[
	FE::Option( "CreateFulltextCatalog" )
	ShouldGenerate
	FE::Bucket( "100" )
	
	"CREATE FULLTEXT CATALOG "
	
	/* Name of the catalog. */
	< QuotedName >
	
	/* Name of the filegroup of which the new catalog will be part. */
	[
		"\n" 
		"ON FILEGROUP "
		<
		    PushReference( "SQLServer_Filegroup_Ref" ) 
		        QuotedName 
		    Pop
		>
	]
	
	/* Specify the root directory for the catalog.*/
	[
	    "\n" 
	    "IN PATH '" 
	    < Property( "File_Path" ) > 
	    "'"
	]
	
	/*Specify if the catalog is accent sensitive */
	[
		"\n" 
		"WITH ACCENT_SENSITIVITY = "
		LookupProperty( "Is_Accent_Sensitive", "true", "ON", "false", "OFF" )
	]
	
	/* Specify that the catalog is the default catalog.*/
	[
	    IsPropertyTrue( "Is_Default" ) 
	    "\n" 
	    "AS DEFAULT"
	]

	
	/* Set the authorization option. */
	[
	    "\n" 
	    "AUTHORIZATION " 
	    < 
	        PushReference( "Authorization_Ref" ) 
	            QuotedName 
	        Pop 
	    > 
	]
	
	FE::EndOfStatement
	
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Fulltext_Index
[
	FE::Option( "CreateFulltextIndex" )
	ShouldGenerate
	FE::Bucket( "110" )
	"CREATE FULLTEXT INDEX ON "
	
	/* Name of the table that contains the column/s included in the full-text index.*/
	[
	    PushOwner 
	        < QuotedName > 
	    Pop
	]
	" "
	[
		"( "
		<
			ForEachOwnee("SQLServer_Fulltext_Index_Column" )
			{
				ListSeparator( ", " )
				QuotedName
				[
				    " TYPE COLUMN " 
				    < 
				        PushReference( "Type_Column_Ref" ) 
				            QuotedName 
				        Pop 
				    >
				]
				[
				    " LANGUAGE " 
				    < Property( "Language" ) > 
				]
			}
		>
		" )"
	]
		
	/* Specify the name of the unique key index.*/
	"\n" 
	"KEY INDEX "
	PushReference( "Key_Group_Ref" ) 
	    QuotedName 
	Pop
	
	/* Specify the full-text catalog used for the full-text index.*/
	[
	    "\n" 
	    "ON " 
	    < 
	        PushReference( "SQLServer_Fulltext_Catalog_Ref" ) 
	            QuotedName 
	        Pop 
	    >
	]
	 
	/* Specify the details regarding change tracking. */
	[
		"\n" 
		"WITH CHANGE_TRACKING " 
		<
			@if ( Equal( Property( "Change_Tracking_Type" ), "Off No Population" ) )
			{ 
			    "OFF, NO POPULATION"
			}
			@else
			{ 
			    UpperCase( Property( "Change_Tracking_Type" ) ) 
			}
		>
	]

	FE::EndOfStatement
	
	/* Specify the state of the full-text index. */
	[
		"\n" 
		"ALTER FULLTEXT INDEX ON "
		PushOwner 
		    < QuotedName > 
		Pop 
		"\n"
		< LookupProperty( "Is_Disabled", "true", "DISABLE", "false", "ENABLE" ) >
		FE::EndOfStatement
	]

	[
		"\n" 
		"ALTER FULLTEXT INDEX ON "
		PushOwner 
		    < QuotedName > 
		Pop 
		"\n"
		Switch( Property( "Population_Mode" ) )
		{
			Choose( "Full" )
			{ 
			    "START FULL POPULATION" 
			}
			Choose( "Incremental" )
			{ 
			    "START INCREMENTAL POPULATION" 
			}
			Choose( "Update" )
			{ 
			    "START UPDATE POPULATION" 
			}
			Choose( "Stop" )
			{ 
			    "STOP POPULATION" 
			}
		}
		FE::EndOfStatement
	]
			
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Fulltext_Index_Column
[
	FE::Option( "CreateFulltextIndex" )
	ShouldGenerate
	FE::Bucket( "115" )
	/* If a fulltext index column is created, add it to it's owner */
	
	"ALTER FULLTEXT INDEX ON "
	/*Table containing the fulltext index */
	< 
	    PushOwner 
	    [ 
	        PushOwner 
	        [ 
	            Property( "Physical_Name" ) 
	        ] 
	        Pop 
	    ] 
	    Pop 
	>
	
	"\n" 
	"ADD (" 
	< QuotedName >
	[
		" TYPE COLUMN " 
		< 
		    PushReference( "Type_Column_Ref" ) 
		    [ 
		        Property( "Physical_Name" ) 
		    ] 
		    Pop 
		> 
	]
	[
	    "\n" 
	    "LANGUAGE " 
	    Property( "Language" )
	]
	")"
	[
	    "\n" 
	    IsPropertyTrue( "Do_Not_Populate" ) 
	    "WITH NO POPULATION"
	]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Login
[
	FE::Option( "CreateLogin" )
	ShouldGenerate
	OnceForObject( "CreateLogin" )
	
	/* Login can reference certificate, asymm key, database (bucket #50), credential (bucket #54) */
	[ 
	    PushReference( "Certificate_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	[ 
	    PushReference( "Asymmetric_Key_Ref" ) 
	        [ Execute( "Create Referenced Object" ) ] 
	    Pop 
	]
	
	/* Store the login name. */
	Set( "var_LoginName", < QuotedName > )
	
	FE::Bucket( "55" )

	"CREATE LOGIN " 
	
	/*Specify the name of the login.*/
	Value( "var_LoginName" )
	
	Set( "var_Authentication", Property( "Authentication_Type" ) )
	
	@if ( Equal( Value( "var_Authentication" ), "Password" ) )
	{
		/* Specify the password for the login that is being created.*/
		"\n" 
		"WITH PASSWORD = "  
		[ 
		    FE::Option( "OtherOptionsPassword" ) 
		    "'" 
		    FE::Password 
		    "'" 
		]
		
		/* Specify the options */
		[
			"\n"
			<
				Separator
				(
				    " ",		
					[ IsPropertyTrue( "Hashed" ) "HASHED" ]
					[ IsPropertyTrue( "Password_Must_Change_On_Next_Logon" ) "MUST_CHANGE" ]
				)
			>
		]
		[
			",\n"
			<
				Separator
				(
				    ",\n",
					[
					    "SID = " 
					    < Property( "Server_Id" ) >
					],
					[
					    "DEFAULT_DATABASE = " 
					    < 
					        PushReference( "SQLServer_Database_Ref" ) 
					            Property( "Name" ) 
					        Pop
					    > 
					],
					[
					    "DEFAULT_LANGUAGE = " 
					    < Property( "Language" ) >
					],
					[
					    "CHECK_EXPIRATION = " 
					    < LookupProperty( "Check_Expiration", "true", "ON", "false", "OFF" ) > 
					],
					[
					    "CHECK_POLICY = " 
					    < LookupProperty( "Check_Policy", "true", "ON", "false", "OFF" ) >
					],
					[
					    "CREDENTIAL = " 
					    <
					        PushReference( "Credential_Ref" ) 
					            Property( "Name" ) 
					        Pop
					    >
					]
				)
			>
		]
	}
	@else
	{
		"\n" 
		"FROM "
		<
			Switch( Value( "var_Authentication" ) )
			{
				Choose( "Windows" )
				{
					[
						"WINDOWS"
						[
							"\n" 
							"WITH "
							<
								Separator
								(
								    ", ",
									[
									    "DEFAULT_DATABASE = " 
									    <
									        PushReference( "SQLServer_Database_Ref" ) 
									            Property( "Name" ) 
									        Pop
									    >
									],
									[
									    "DEFAULT_LANGUAGE = " 
									    < Property( "Language" ) >
									]
								)
							>
						]
					]
				}
				Choose( "Certificate" )
				{
					[
					    "CERTIFICATE " 
					    <
					        PushReference( "Certificate_Ref" ) 
					            Property( "Name" ) 
					        Pop
					    >
					]
				}
				Choose( "Asymmetric Key" )
				{
					[
					    "ASYMMETRIC KEY " 
					    <
					        PushReference( "Asymmetric_Key_Ref" ) 
					            Property( "Name" ) 
					        Pop
					    >
					]
				}
			}
		>
	}
	
	FE::EndOfStatement
	
	[
	    "ALTER LOGIN "
	    Value( "var_LoginName" )
	    < 
	        "\n" 
	        LookupProperty( "Is_Disabled", "true", "DISABLE", "false", "ENABLE" ) 
	    >
	    FE::EndOfStatement
	]

	[
		Equal ( Value( "var_Authentication" ), "Password" )
	    "ALTER LOGIN "
	    Value( "var_LoginName" )
	    "\n" 
	    "WITH PASSWORD = "  
	    [ 
	        FE::Option( "OtherOptionsPassword" ) 
	        "'" 
	        FE::Password 
	        "'" 
	    ]
	    < 
	        "\n" 
	        IsPropertyTrue( "Unlock_Password" ) 
	        "UNLOCK"
	    >
	    FE::EndOfStatement
	]
			
	/* Add the login as a member of a fixed server role. */
	Set( "var_LoginName", Property( "Name" ) )
	[
		ForEachOwnee( "Role_Usage" )
		{
			< Execute("Create Role_Usage") >
		}
	]
	Remove( "var_LoginName" )
	Remove( "var_Authentication" )
	
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Partition_Function
[
	FE::Option( "CreatePartitionFunction" )
	ShouldGenerate
	FE::Bucket( "76" )
	
	"CREATE PARTITION FUNCTION "
	
	/* Name of the partition function.*/
	< QuotedName >
	
	/* Datatype of the column used for partitioning.*/
	"( " 
	Property( "Physical_Data_Type" ) 
	" )"
	
	/* Specify the side of the boundary value interval.*/
	"\n" 
	"AS RANGE " 
	[ Property( "Range_Partition_Boundary_Side") ]
	
	/* Boundary values for each partition. */
	"\n" 
	"FOR VALUES " 
	"( " 
	[ Property( "Partition_Values" ) ] 
	" )"
	
	FE::EndOfStatement
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "PARTITION FUNCTION") 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Partition Function comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Partition_Scheme
[
	FE::Option( "CreatePartitionScheme" )
	ShouldGenerate
	FE::Bucket( "80" )
	
	"CREATE PARTITION SCHEME "
	/* Name of the partition scheme.*/
	 < QuotedName >
	
	/* Specify the name of the partition function using the partition scheme.*/
	"\n" 
	"AS PARTITION "
	<
	    PushReference( "Partition_Function_Ref" ) 
	        Property( "Name" ) 
	    Pop
	>
	
	/* Specify if all partitions map to the filegroup provided in filegroup name.*/
	[
	    "\n" 
	    IsPropertyTrue( "Map_All" ) 
	    "ALL "
	]
	
	/* Specify the names of the filegroups to hold the partitions. */
	"\n" 
	"TO ( " 
	< 
		ForEachReference( "SQLServer_Filegroups_Ref", "Exact" )
		{
			ListSeparator( ", " )
			@if ( IsPropertyTrue( "Is_Primary" ) )
			{
				"[" 
				Property( "Name" ) 
				"]"
			}
			@else
			{
				Property( "Name" )
			}
		}
	>
	" )"

	FE::EndOfStatement
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		FE::Bucket( "80" )
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "PARTITION SCHEME") 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Domain comments and UDPs */
		"\n"
		Execute( "Clause: Specify Extended Properties" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Physical_File
[
	OnceForObject( "Create SqlServer Physical File" )
	FE::RecordCreate
	PushOwner
	PushOwner
	"ALTER DATABASE " 
	QuotedName 
	Pop 
	Pop
	"\nADD FILE "
	
	"\n(\n\t"
	"NAME = '" 
	Property( "Name" ) 
	"'"
	<[
		", \n\t" 
		"FILENAME = '" 
		< Property( "File_Name" ) >
		"'"
	]>
	[
		", \n\t" 
		"SIZE = " 
		<Property( "File_Size" )>
	]
	[
		", \n\t" 
		"MAXSIZE = " 
		< Property( "Max_Size" ) >
	]
	[
		", \n\t" 
		"FILEGROWTH = " 
		< Property( "File_Growth_Size" ) >
		[
			Equal( Property( "File_Growth_By_Type" ), "Percent" ) 
			"%"
		]
	]
	"\n) "
	[
		"\nTO FILEGROUP "
		PushOwner
		[
			@if(IsPropertyModified( "Is_Default" ))
			{
				IsPropertyTrue( "Is_Default" ) 
				"DEFAULT"
			}
			@else
			{
				QuotedName
			}
		]
		Pop
	]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_Symmetric_Key
[
	FE::Option( "CreateSymmetricKey" )
	FE::Bucket( "70" )
	ShouldGenerate
	
	/* Create the referenced Symmetric Keys */
	ForEachReference( "Symmetric_Keys_Ref" )
	{
		Execute( "Create SQLServer_Symmetric_Key" )
		
		[
			/* If the symmetric key was encrypted with another key, that key must be opened first. */
			OnceForObject( "Open Symmetric Key" )
			"OPEN SYMMETRIC KEY "
			< QuotedName >
			[
    		
				/* Set the variable required to emit DECRYPTION BY PASSWORD clause. */
				Set( "var_IsPasswordDecryption", "true" )
    			
				[
					"\n" 
					"DECRYPTION BY  " 
					"\n" 
					<
						Separator
						(
						    ",\n",
							[ "CERTIFICATE "    < FormatProperty( "Certificates_Ref", "p:Name", "d:, "      ) > ],
							[ "SYMMETRIC KEY "  < FormatProperty( "Symmetric_Keys_Ref", "p:Name", "d:, "    ) > ],
							[ "ASYMMETRIC KEY " < FormatProperty( "Asymmetric_Keys_Ref", "p:Name", "d:, "   ) > ]
						)
					>
                   
					/* If the above statement succeeded, suppress emission of Password clause*/ 
					Set( "var_IsPasswordDecryption", "false" )
				]
                
				[
					/* Emit PASSWORD clause, if no other decryption mechanism was specified*/
					Equal( Value( "var_IsPasswordDecryption" ), "true" )
					"\n" 
					"DECRYPTION BY PASSWORD = " 
					[ 
					    FE::Option( "OtherOptionsPassword" ) 
					    "'" 
					    FE::Password 
					    "'" 
					]
				]
                
				Remove( "var_IsPasswordDecryption" )
				FE::EndOfStatement
			]
		]		
	}
	OnceForObject( "Create Symmetric Key" )
			
	"CREATE SYMMETRIC KEY " 
	
	/* Specify the unique name by which the symmetric key is known in the database.*/
	< QuotedName >
	
	/* Specify the name of the database user or application role that will own this key.*/
	[
	    "\n" 
	    "AUTHORIZATION " 
	    < 
	        PushReference( "Authorization_Ref" ) 
	            QuotedName 
	        Pop 
	    >
	]
	
	/*Specify the algorithm used. */ 
	[
		"\n" 
		"WITH ALGORITHM = "
		
		Set( "var_Algorithm", Property( "Algorithm_Type") )
		<
			Switch( Value( "var_Algorithm") )
			{
				Choose( "Triple DES"  ) { "TRIPLE_DES"  }
				Choose( "128-bit AES" ) { "AES_128"     }
				Choose( "192-bit AES" ) { "AES_192"     }
				Choose( "256-bit AES" ) { "AES_256"     }
				Default
				{
					UpperCase( Value( "var_Algorithm" ) )
				}
				
			}  
		>
		Remove( "var_Algorithm")
	]
	
	/* Provide information about the encryption mechanism.*/
	[
	
	    /* Set the variable required to emit ENCRYPTION BY PASSWORD clause. */
		Set( "var_IsPasswordEncryption", "true" )
		
        [
            "\n" 
            "ENCRYPTION BY  " 
            "\n" 
            <
                Separator
                (
                    ",\n",
                    [ "CERTIFICATE "    < FormatProperty( "Certificates_Ref", "p:Name", "d:, "      ) > ],
                    [ "SYMMETRIC KEY "  < FormatProperty( "Symmetric_Keys_Ref", "p:Name", "d:, "    ) > ],
                    [ "ASYMMETRIC KEY " < FormatProperty( "Asymmetric_Keys_Ref", "p:Name", "d:, "   ) > ]
                )
            >
           
            /* If the above statement succeeded, suppress emission of Password clause*/ 
            Set( "var_IsPasswordEncryption", "false" )
        ]
        
        [
            /* Emit PASSWORD clause, if no other encryption mechanism was specified*/
            Equal( Value( "var_IsPasswordEncryption" ), "true" )   
            "\n" 
            "ENCRYPTION BY PASSWORD = "  
            [ 
                FE::Option( "OtherOptionsPassword" ) 
                "'" 
                FE::EncryptionPassword 
                "'" 
            ]
        ]
        
        Remove( "var_IsPasswordEncryption" )
    ]

	
	FE::EndOfStatement
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_XML_Index
[
	FE::Option( "CreateXMLIndex" )
	ShouldGenerate
	
	"CREATE "
	
	/* Primary Opfion */
	[
	    IsPropertyTrue( "Is_Primary_XML_Index" ) 
	    "PRIMARY "
	]
	
	"XML INDEX "
	
	/* Name of the Index */
	< QuotedName >
	" ON "
	<
		/* Name of the table that contains the column/s included in the XML index.*/
		PushOwner
            [ FE::OwnerOverride( "true" ) "." ] 
		    QuotedName
		Pop
	>
	
	" ( "
	<
	    PushReference( "Attribute_Ref" ) 
	        QuotedName 
	    Pop	
	>
	" )"
	
	[
		"\n"
		"USING XML INDEX "
		< 
		    PushReference( "Primary_XML_Index_Ref" ) 
		        Property( "Name" ) 
		    Pop 
		>
		" " 
		UpperCase( Property( "Secondary_XML_Index_Type" ) )
	]
	[
		"\n\t"	
		"WITH"
		"\n\t("
		"\n\t\t"
		<
			Separator
			(
			    ",\n\t\t",
				[ "PAD_INDEX = "				LookupProperty( "SQLServer_Pad_Index", "true", "ON", "false", "OFF" )      ],
				[ "FILLFACTOR = "				< Property( "SQLServer_Fill_Factor" ) >                                    ],
				[ "SORT_IN_TEMPDB = "			LookupProperty( "SQLServer_Sort_In_Temp_DB", "true", "ON", "false", "OFF" ) ],
				[ "STATISTICS_NORECOMPUTE = "	LookupProperty( "SQLServer_Keep_Existing_Statistics", "true", "ON", "false", "OFF" )   ],
				[ "DROP_EXISTING = "			LookupProperty( "SQLServer_Drop_Existing_Index", "true", "ON", "false", "OFF" )  ],
				[ "ALLOW_ROW_LOCKS = "			LookupProperty( "Allow_Row_Locks", "true", "ON", "false", "OFF" )           ],
				[ "ALLOW_PAGE_LOCKS = "			LookupProperty( "Allow_Page_Locks", "true", "ON", "false", "OFF" )          ],
				[ "MAXDOP = "				    < Property( "SQLServer_Max_Parallel" ) >                                    ]
			)
		>
		"\n\t)"
	]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create SQLServer_XML_Schema_Collection
[
	FE::Option( "CreateXMLSchemaCollection" )
	FE::Bucket( "62" )
	
	"CREATE XML SCHEMA COLLECTION  "
	
	/* Specify the SQL identifier for the XML schema collection.*/
	[ FE::OwnerOverride( "true" ) "." ] 
	QuotedName

	/*Specify the expression.*/
	" AS"
	"\n" 
	"N'" 
	Property( "Expression" ) 
	"'"
	FE::EndOfStatement
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" )
		[ 
		    PushReference( "Schema_Ref" ) 
		        Set( "var_Level0Name", Property( "Name" ) ) 
		    Pop 
		]
		Set( "var_Level1Type", "XML SCHEMA COLLECTION") 
		Set( "var_Level1Name", Property( "Name" ) )
		
		/* Generate XML Schema Collection comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Schema
[
	FE::Option( "CreateSchema" )
	ShouldGenerate
	OnceForObject( "CreateSchema" )
	
	/*schema can reference user.*/
	[ 
	    PushReference( "Owner_Ref" ) 
	    [ 
	        Execute( "Create Referenced Object" ) 
	    ] 
	    Pop 
	]
	
	FE::Bucket( "55" )
	"CREATE SCHEMA "
	
	/* Schema Name Clause */
	<
		Separator
		( 
		    " ", 
			[ QuotedName ],
			[
				"AUTHORIZATION " 
				<
				PushReference( "Owner_Ref" )
				    QuotedName
				Pop
				>
			]
		)
	>
	FE::EndOfStatement
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" ) 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Schema comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]

	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
	
]
SPItemEnd

SPItemBegin [keep format] = Create Stored_Procedure
[
	OnceForObject( [ Repush( "1" ) ObjectId Pop ] "Create Stored_Procedure" )
	[
		ShouldGenerate
		FE::Bucket( "100" ) 
		"\n"
		
		/* Check if the valid FE options are selected. */
		Set( "var_bProceed", "false" )
		Switch( Property( "Type" ) )
		{
			Choose( "Table Level" )
			{
				FE::Option( "TableCreateProcedure" )
				@if( IsPropertyTrue( "Generate_As_Pre_Script" ) )
				{
					FE::Bucket( "57" )
				}
				@else
				{
					FE::Bucket( "100" )
				}
				Set( "var_bProceed", "true" )
			}
			Choose( "Model Level" )
			{
				FE::Option( "ModelCreateProcedure" )
				Set( "var_bProceed", "true" )
			}
		}
		Equal( Value( "var_bProceed" ), "true" )
		
        FE::ExpandERwinMacro( "Template_Code" )
		FE::EndOfStatement
        [
            IsPropertyTrue( "SQLServer_Startup" ) 
            "\n\n"
            "EXEC sp_procoption '"
            PushReference( "Schema_Name" )
                Property( "Physical_Name" )
                "', 'startup', '1'"
            Pop
            FE::EndOfStatement
        ]
		[
			/* Generate comments and UDP's as Extended Properties. */
			/* Set the variables required by the "Clause: Specify Extended Properties". */
			Set( "var_RemoveVariables", "true" ) 
			Set( "var_Operation", "sp_addextendedproperty" ) 
			Set( "var_Comment", "Definition" )
			Set( "var_Level0Type", "SCHEMA" ) 
			PushReference( "Schema_Ref" ) 
			    Set( "var_Level0Name", Property( "Name" ) ) 
			Pop
			Set( "var_Level1Type", "PROCEDURE" ) 
			Set( "var_Level1Name", Property( "Name" ) )	
			
			/* Generate comments and UDPs */
			"\n"
			Execute( "Clause: Specify Extended Properties" )
		]
		[ 
	    	FE::Bucket( "150" ) 
	    	ForEachOwnee( "Permission" )
			{
				Execute( "Create Permission" )
			}
		]
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Synonym
[
	FE::Option( "ModelCreateSynonym" )
	ShouldGenerate
	FE::Bucket( "120" )
	"CREATE SYNONYM "

	/* Name of the Synonym */
    [ FE::OwnerOverride( "true" ) "." ] 
    QuotedName
	
	"\n" 
	"FOR "
	< Property( "Remote_Object_Name" ) >
			
	FE::EndOfStatement

	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" )
		[ 
		PushReference( "Schema_Ref" ) 
		    Set( "var_Level0Name", Property( "Name" ) ) 
		Pop 
		]
		Set( "var_Level1Type", "SYNONYM" ) 
		Set( "var_Level1Name", Property( "Name" ) )
		
		/* Generate Synonym comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Table Check Constraint Usage
[
	/* Create the table level constraint for the validation rule. */
	[
		PushReference( "Validation_Rule_Ref" )
			IsPropertyTrue( "Generate_As_SQL_92_Format" )
		Pop
		PushOwner
		@if ( IsGlobalFlagSet( ObjectId "Create Entity"  ) )
		{
		    Pop
		}
		@else
		{
			Pop

			/* There is no way to alter a column level constraint value,
			*  so drop and recreate the entire table.
			*/
			FE::Bucket( "94" )
			FE::RecordAlter
			PushOwner
				"ALTER TABLE "
				[ FE::OwnerOverride( "true" ) "." ]
				QuotedName
			Pop
			" ADD CONSTRAINT " 
			[
			    FE::Option( "ConstraintName" ) 
			    QuotedName
			]
			[
				Set( "var_bIsNotForReplication", "false" )
				[ 
				    IsPropertyTrue( "Is_Not_For_Replication" ) 
				    Set( "var_bIsNotForReplication", "true" ) 
				]
				PushReference( "Validation_Rule_Ref" )
				[
					"\n\t\t"  
					"CHECK  " 
					[ 
					    Equal( Value( "var_bIsNotForReplication" ) , "true" )  
					    "NOT FOR REPLICATION "
					]
					[
					    "( " 
                        FE::ExpandERwinMacro( "Server_Value" ) 
					    " ) "
					]
				]
				Pop
				Remove( "var_bIsNotForReplication" )
			]
			FE::EndOfStatement
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Trigger
[	
	OnceForObject( "Create Trigger" )
	PushOwner 
	    Set( "var_ObjectType", ObjectType ) 
	Pop
	Set( "var_bProceed", "false" )
	[
        Switch( Value( "var_ObjectType" ) )
        {
            Choose( "Entity" )
            {    
				FE::Option( "GenerateUserDefinedTrigger" )
                Set( "var_bProceed", "true" )
            }
            Choose( "View" )
            {
                FE::Option( "ViewCreateTrigger" )
                Set( "var_bProceed", "true" )
            }
            Choose( "SQLServer_Database" )
            {
                FE::Option( "CreateDatabaseTrigger" )
                Set( "var_bProceed", "true" )
            }
            Choose( "Model" )
            {
                FE::Option( "CreateServerTrigger" )
                Set( "var_bProceed", "true" )
            }
        }
    ]
    
    [
        @if ( Equal( Value( "var_bProceed" ), "true" ) )
        {
			FE::RecordCreate
			ShouldGenerate
			FE::Bucket( "110" )
			<@if ( IsDefaultRITrigger )
			{
        		Property( "Trigger_Body", "no_translate" )
			}
			@else
			{
                FE::ExpandERwinMacro( "Trigger_Body" )
			}>
			[
				@if ( IsMatch(Value( "var_ObjectType" ), "SQLServer_Database", "Model" ) )
				{
					FE::EndOfStatement
				}
				@else
				{
					FE::EndOfStatement( "true" )
				}
			]
			[
			    < LookupProperty( "Trigger_Status", "0", "ENABLE", "1", "DISABLE" ) >
			    " TRIGGER "
                [ FE::OwnerOverride( "true" ) "." ] 
	            QuotedName
			    " ON "
			    [
			    	PushOwner 
			    	[
                        [ FE::OwnerOverride( "true" ) "." ] 
	                    QuotedName
			    	] 
			    	Pop
			    ]
			    FE::EndOfStatement
			]
		}
	]
	/* Generate comments and UDP's as Extended Properties. */
	[
		Equal( Value( "var_bProceed" ), "true" )
		IsMatch( Value( "var_ObjectType" ), "SQLServer_Database", "Model" )
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "TRIGGER" ) 
		Set( "var_Level0Name", Property( "Name" ) )
		
		/* Generate Domain comments and UDPs */
		"\n"
		Execute( "Clause: Specify Extended Properties" )
	]
	[
		Equal( Value( "var_bProceed" ), "true" )
		IsMatch( Value( "var_ObjectType" ), "Entity", "View" )
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true" ) 
		Set( "var_Operation", "sp_addextendedproperty" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" )
		PushReference( "Schema_Ref" ) 
		    Set( "var_Level0Name", Property( "Name" ) ) 
		Pop 
		
		@if ( Equal( Value( "var_ObjectType" ), "Entity" ) )
		{
			Set( "var_Level1Type", "TABLE" )
			PushOwner 
			    Set( "var_Level1Name", Property( "Physical_Name" ) ) 
			Pop
		}
		@else
		{
			Set( "var_Level1Type", "VIEW" )
			PushOwner 
			    Set( "var_Level1Name", Property( "Name" ) ) 
			Pop
		}
		Set( "var_Level2Type", "TRIGGER" )
		Set( "var_Level2Name", Property( "Name" ) )
		
		/* Generate Function comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
    ]
	Remove( "var_ObjectType" )
	Remove( "var_bProceed" )
]
SPItemEnd

SPItemBegin [keep format] = Create User_Id
[
	FE::Option( "CreateUserId" )
	ShouldGenerate
	OnceForObject( "Create User_Id" )

	/* User can reference asymm key/certificate/login/schema */
	[ 
    PushReference( "SQLServer_Asymmetric_Key_Ref" ) 
        [ Execute( "Create Referenced Object" ) ] 
    Pop 
	]
	
	[ 
    PushReference( "SQLServer_Certificate_Ref" ) 
        [ Execute( "Create Referenced Object" ) ] 
    Pop 
	]
	
	[ 
    PushReference( "SQLServer_Login_Ref" ) 
        [ Execute( "Create Referenced Object" ) ] 
    Pop 
	]
	
	[ 
    PushReference( "SQLServer_Schema_Ref" ) 
        [ Execute( "Create Referenced Object" ) ] 
    Pop 
	]
	
	FE::Bucket( "55" )
	"CREATE USER "

	/* Name of the User */
	< QuotedName >
	
	/* Login Type */
	[
		Switch( Property( "SQLServer_Login_Type" ) )
		{
			Choose( "Login" )
			{
				"\n" 
				"FOR LOGIN " 
				PushReference( "SQLServer_Login_Ref" ) 
				    QuotedName 
				Pop
			}
			Choose( "Certificate" )
			{
				"\n" 
				"FOR CERTIFICATE " 
				PushReference( "SQLServer_Certificate_Ref" ) 
				    QuotedName
				Pop
			}
			Choose( "Asymmetric Key" )
			{
				"\n" 
				"FOR ASYMMETRIC KEY " 
				PushReference( "SQLServer_Asymmetric_Key_Ref" ) 
				    QuotedName
				Pop
			}
			Choose( "No Login" )
			{
				"\n" 
				"WITHOUT LOGIN" 
			}
		}
	]
	/* Default schema */
	
	[
	    "\n" 
	    "WITH DEFAULT_SCHEMA = " 
	    PushReference( "SQLServer_Schema_Ref" ) 
	        < Property( "Name" ) > 
	    Pop 
	]
	
	FE::EndOfStatement
	
	/* Add the user as a member of another role. */
	Set( "var_UserName", Property( "Name" ) )
	[
		ForEachOwnee( "Role_Usage" )
		{
			< Execute("Create Role_Usage") >
		}
	]
	Remove( "var_UserName" )
	
	/* Generate comments and UDP's as Extended Properties. */
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_RemoveVariables", "true"                      ) 
		Set( "var_Operation",       "sp_addextendedproperty"    ) 						
		Set( "var_Comment",         "Comment"                   )			
		Set( "var_Level0Type",      "USER"                      ) 
		Set( "var_Level0Name",      Property( "Name" )          )
		
		/* Generate Schema comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
	]
	
	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]		
]
SPItemEnd

SPItemBegin [keep format] = Create Validation_Rule
[
	FE::Bucket( "56" )
	FE::Option( "CreateRule" )
	ShouldGenerate 
	IsPropertyFalse( "Generate_As_SQL_92_Format" )

	OnceForObject( "Create Validation_Rule" )
	[
		"CREATE RULE "
		[ FE::OwnerOverride( "true" ) "." ]
		< QuotedName >
		"\n\t" 
		"AS " 
        FE::ExpandERwinMacro( "Server_Value" )
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Create View
[
	ShouldGenerate
	OnceForObject( "Create View" )
	[
		FE::Option( "ViewPreScript" ) 
		FE::Bucket( "90" )
		ForEachReference( "Script_Templates_Ref" )
		{
			ShouldGenerate
			FE::Bucket( "90" )
			IsPropertyTrue( "Generate_As_Pre_Script" )
            FE::ExpandERwinMacro( "Template_Code" )
			FE::EndOfStatement( "true" )
		}
	]

	[
	    FE::Option( "CreateView" )
		FE::Bucket( "90" )
		FE::RecordCreate
 /*---*/
	    [
			FE::Bucket( "90" )
            @if ( IsPropertyNotNull( "User_Defined_SQL" ) )
            {
                /* User defined view. Emit the view SQL. */
                Property( "User_Defined_SQL" )
                FE::EndOfStatement
            }
            @else
            {
                /* Inline code from old Create View Internal */
			    [
				    "CREATE VIEW " 
				    /* Name of the view.*/
				    [ FE::OwnerOverride( "true" ) "." ] 
				    < QuotedName >
    				
				    /* Names to be used for the columns in the view. */
				    [
					    "("
					    <
						    ForEachReference( "Physical_Columns_Order_Ref" )
						    {
							    ShouldGenerate
							    ListSeparator( "," )
							    QuotedName
						    }
					    >
					    ")"
				    ]
    				
				    /* View Options */
				    [
					    "\n" 
					    "WITH "
					    <
						    Separator
						    (
						        ", ",
							    [ IsPropertyTrue( "SQLServer_Is_Obfuscated" )      "ENCRYPTION"    ],
							    [ IsPropertyTrue( "SQLServer_Use_Schema_Binding" )  "SCHEMABINDING" ],
							    [ IsPropertyTrue( "SQLServer_Return_View_Metadata" )   "VIEW_METADATA" ]
						    )
					    >
				    ]
    				
				    "\n" 
				    "AS"
				    "\n"
				    <
					    "SELECT " 
					    [ 
					        LookupProperty( "Select_Type", "2", "DISTINCT" ) 
					        " " 
					    ]
					    <
						    ForEachReference( "Physical_Columns_Order_Ref" )
						    {
							    ShouldGenerate
							    ListSeparator( "," )
							    [
								    PushReference( "Parent_Relationship_Ref" )
								    [
									    [
										    Property( "Alias_Name", "fail_if_empty" ) 
										    "."
									    ]
									    [
										    Equal( [ Property( "Alias_Name" ) ], "" )
										    PushReference( "Parent_Entity_Ref" )
										    [
											    [ FE::OwnerOverride( "true" ) "." ] 
											    QuotedName 
											    "."
										    ]
										    Pop
									    ]
								    ]
								    Pop
								    [
									    PushReference( "Parent_Attribute_Ref" )
										    PushOwner
										        @if ( Equal( ObjectType, "Entity" ) )
										        {
										            Pop 
										                QuotedName
										            PushOwner
										        }
										        @elseif ( Equal( ObjectType, "View" ) )
										        {
										            Pop 
										                Property( "Name" )
										            PushOwner
										        }
										    Pop
									    Pop
								    ]
							    ]
							    [ Property( "View_Expression" ) ]
						    }
					    >
					    "\n\t" 
					    "FROM "
					    <
						    ForEachReference( "Child_Relationships_Ref" )
						    {
							    ShouldGenerate
							    ListSeparator( "," )
							    [
							        PushReference( "Parent_Entity_Ref" )
								        [ FE::OwnerOverride( "true" ) "." ] 
								        QuotedName
							        Pop
							    ]
							    [
							        " " 
							        < Property( "Alias_Name" ) >
							    ]
						    }
					    >
					    [
					        "\n\t\t"	
					        "WHERE " 
					        < Property( "Where_Clause" ) >
					    ]
					    [
					        "\n\t\t"	
					        "GROUP BY " 
					        < Property( "Group_By_Clause" ) >
					    ]
					    [
					        "\n\t\t"	
					        "HAVING " 
					        < Property( "Having_Clause" ) >
					    ]
					    [
					        "\n\t\t"	
					        "ORDER BY " 
					        < Property( "Order_By_Clause" ) >
					    ]
				    >
				    [
				        "\n\t\t"	
				        LookupProperty( "Restriction_Type", "1", "WITH CHECK OPTION" )
				    ]
				    FE::EndOfStatement 
			    ]
			}
		]
/*---*/            
	]

    [
        /*Generate all unique View indexes (AK)*/
		ForEachOwnee( "Key_Group" )
		{
			[
			    FE::Bucket( "90" ) 
			    Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" )
			    FE::Option( "CreateViewIndexAK" )
			    Execute( "Create Key_Group" )
			]
		}
		
		/*Generate all non-unique View indexes (IE)*/
		ForEachOwnee( "Key_Group" )
		{
			[
			    FE::Bucket( "90" ) 
			    Equal( Left( Property( "Key_Group_Type" ), 2 ), "IE" )
			    FE::Option( "CreateViewIndexIE" )
			    Execute( "Create Key_Group" )
			]
		}
	]
	
	/* Generate view-level stored procedures and functions */
	[
		FE::Bucket( "100" )
		ForEachReference( "Stored_Procedures_Ref" )
		{
			ShouldGenerate
			Equal( Property( "Type", "no_translate" ), "1" ) /* table - level */
			[
			    FE::Option( "ViewDropStoredProcedure" ) 
			    Execute( "Drop Stored_Procedure" )
			]
			[
			    FE::Option( "ViewCreateStoredProcedure" ) 
			    Execute( "Create Stored_Procedure" )
			]
		}
	]
	[
		FE::Bucket( "100" )
		ForEachReference( "Functions_Ref" )
		{
			ShouldGenerate
			Equal( Property( "Type", "no_translate" ), "1" ) /* table - level */
			[
			    FE::Option( "ViewDropFunction" ) 
			    Execute( "Drop Function" )
			]
			[
			    FE::Option( "ViewCreateFunction" ) 
			    Execute( "Create Function" )
			]
		}
	]

	[
		FE::Option( "ViewPostScript" ) 
		FE::Bucket( "90" )
		ForEachReference( "Script_Templates_Ref" )
		{
			ShouldGenerate
			FE::Bucket( "90" )
			IsPropertyFalse( "Generate_As_Pre_Script" )
            FE::ExpandERwinMacro( "Template_Code" )
			FE::EndOfStatement( "true" )
		}
	]
	
    [
        FE::IsAlterScriptGeneration 
        ForEachReference("Parent_Relationships_Ref")
        {
            [
                PushReference("Child_Entity_Ref") 
                [ 
                    Equal( ObjectType, "View" )
                    @ifnot ( IsDeleted )
                    {
                        Execute( "Create View" )
                    }
                ]
                Pop
            ]
        }
    ]
	
	/*Generate UDP's and Comments as Extended Properties*/
	[
		/* Set the variables required by the "Clause: Specify Extended Properties". */
		Set( "var_Operation", "sp_addextendedproperty" )
		Set( "var_RemoveVariables", "false" ) 
		Set( "var_Comment", "Definition" )
		Set( "var_Level0Type", "SCHEMA" )
		[ 
		    PushReference( "Schema_Ref" ) 
		        Set( "var_Level0Name", Property( "Name" ) ) 
		    Pop 
		]
		Set( "var_Level1Type", "VIEW" )
		Set( "var_Level1Name", Property( "Name" ) )
		
		/* Generate view comments and UDPs */
		Execute( "Clause: Specify Extended Properties" )
		
		/* Generate column comments and UDPs */
		Set( "var_Level2Type", "COLUMN" )
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			Set( "var_ExtendedPropertyValue", Property( "Definition" ) )
			Set( "var_Level2Name", Property( "Name" ) )
			Execute( "Clause: Specify Extended Properties" )
		}
		
		/* Generate key group comments and UDPs */
		Set( "var_Level2Type", "INDEX" )
		ForEachOwnee( "Key_Group" )
		{
			Set( "var_ExtendedPropertyValue", Property( "Definition" ) )
			Set( "var_Level2Name", Property( "Physical_Name" ) )
			Execute( "Clause: Specify Extended Properties" )
		}
		
		/* Remove the variables. */
	    [ Remove( "var_Operation" )             ]
	    [ Remove( "var_Comment" )               ]
	    [ Remove( "var_RemoveVariables" )       ]
	    [ Remove( "var_ExtendedPropertyName" )  ] 
	    [ Remove( "var_ExtendedPropertyValue" ) ]
	    [ Remove( "var_Level0Type" )            ] 
	    [ Remove( "var_Level0Name" )            ]
	    [ Remove( "var_Level1Type" )            ] 
	    [ Remove( "var_Level1Name" )            ]
	    [ Remove( "var_Level2Type" )            ] 
	    [ Remove( "var_Level2Name" )            ]
	]

	[ 
	    FE::Bucket( "150" ) 
	    ForEachOwnee( "Permission" )
		{
			Execute( "Create Permission" )
		}
	]
	
]
SPItemEnd

SPItemBegin [keep format] = Drop Attribute
/* Do not alter if the entire entity was created. */
[
	Set( "var_Proceed", "true" )
	PushOwner 
	[
		IsGlobalFlagSet( ObjectId "Drop Entity" ) 
		Set( "var_Proceed", "false" )
	] 
	Pop
	Equal( Value( "var_Proceed" ), "true" )
	@ifnot ( IsGlobalFlagSet( "DropAttribute" PushOwner ObjectId Pop Property( "Physical_Name" ) ) )
	{	
		/* Check if the lead attribute still exists in the table. */
		Set( "Physical_Name", Property( "Physical_Name" ) )

		PushOwner
		ForEachReference( "Columns_Order_Ref" )
		{
			/* Compare names to determine if the deleted attribute was unified.        */
			/* Logical only attributes will not be included in the  column order list. */
			@if ( Equal( Property( "Physical_Name" ), Value ( "Physical_Name" ) ) )
			{
				
				SetLocalFlag ( "Lead Attribute Exists", "2" )
			}
		}
		Pop
		Remove( "Physical_Name" )
	
		@ifnot ( IsLocalFlagSet( "Lead Attribute Exists" ) )
		{
			FE::Bucket( "40" )
			/*RecordAlterX*/
			/*FESetStringX("Drop Attribute")*/
			FE::RecordAlter
			SetGlobalFlag( ObjectId "Drop Attribute" )
			PushOwner
				"ALTER TABLE " 
				[ FE::OwnerOverride( "true" ) "." ] 
				QuotedName
			Pop
			"\n"
			"  DROP COLUMN " 
			Execute( "Previous Physical Name" )
			 SetGlobalFlag( "DropAttribute" PushOwner ObjectId Pop Property( "Physical_Name" ) )
			FE::EndOfStatement
		}
	}
]
[
	ForEachOwnee( "Check_Constraint_Usage" )
	{
		[ Execute( "Drop Check_Constraint_Usage" ) ]
	}
]
[
	ForEachOwnee( "Default_Constraint_Usage" )
	{
		[ Execute( "Drop Default_Constraint_Usage" ) ]
	}
]

Remove( "var_bProceed" )
SPItemEnd

SPItemBegin [keep format] = Drop Check_Constraint_Usage
	[
		/* Unbind the column validation rule. */
		[
			PushOwner
			[
                Equal( ObjectType, "Attribute" )
				PushOwner
				[
					Equal( ObjectType, "Entity" )
					Set( "var_OwnerIsAttribute", "true" )
				]
				Pop
			]
			Pop

			Equal( Value( "var_OwnerIsAttribute" ), "true" )
	
			/*IsNullX(Execute( "Old Validation Is SQL 92" ) )*/ 
	        Equal( Execute( "Old Validation Is SQL 92" ), "" )
			IsNotInheritedFromUDD
			@ifnot(IsGlobalFlagSet("Drop Check_Constraint_Usage"))
			{
				OnceForObject( "Drop Check_Constraint_Usage" )
				FE::Bucket( "3" )
            	FE::RecordAlter
				"exec sp_unbindrule "
				PushOwner
					"'"
					PushOwner
						[ < Execute( "Previous Owner" ) > "." ] 
						Property( "Physical_Name" )
					Pop
						"." 
						Property( "Physical_Name" )
					"'"
				Pop
				FE::EndOfStatement
			}
		]
	
		/* Unbind the Domain validation rule. */
		[
			PushOwner
			[
			    Equal( ObjectType, "Domain" ) 
			    Set( "var_OwnerIsDomain", "true" )
			]
			Pop
			Equal( Value( "var_OwnerIsDomain" ), "true" )
	
			Equal( Execute( "Old Validation Is SQL 92" ), "" )
			IsNotInheritedFromUDD
			OnceForObject( "Drop Check_Constraint_Usage" )
			FE::Bucket( "3" )
			FE::RecordAlter
			SetGlobalFlag("Drop Check_Constraint_Usage")
			"exec sp_unbindrule "
			PushOwner
				Property( "Physical_Name" )
			Pop
			FE::EndOfStatement
		]
	
		/* Drop the column level constraint for the validation rule. */
		[
			Equal( Value( "var_OwnerIsAttribute"), "true" )
			NotEqual( Execute( "Old Validation Is SQL 92" ), "" )
			OnceForObject( "Drop Check_Constraint_Usage" )
			[
				FE::Bucket( "3" )
	
				PushOwner
					PushOwner
					    "ALTER TABLE " 
					    [ < Execute( "Previous Owner" ) > "." ] 
					    Property( "Physical_Name" )	
					    " DROP CONSTRAINT "
					Pop
				Pop
				Property( "Physical_Name" ) /*Constraint Name*/
				FE::EndOfStatement
			]
		]
		Remove( "var_OwnerIsAttribute")
		Remove( "var_OwnerIsDomain" )
	]
SPItemEnd

SPItemBegin [keep format] = Drop Constraint

/* Build drop table constraint statement.
   Note that a constraint name is required for this statement to generate.
*/
[
	[
		
		FE::Option( "PKConstraintInAlter" )
		Equal( Left( Property( "Key_Group_Type" ), 2 ), "PK" )
		OnceForObject( "Drop Constraint" )
		FE::Bucket( "37" )		
		PushOwner
			"ALTER TABLE " 
			[< Execute("Previous Owner") > "." ] 
			Property( "Physical_Name" )
			"\n"
		Pop
		"DROP CONSTRAINT "
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement		
	]

	[
		FE::Option( "AKConstraintInAlter" )
		Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" )
		OnceForObject( "Drop Constraint" )
		FE::Bucket( "37" )		
		PushOwner
			"ALTER TABLE " 
			[< Execute("Previous Owner") > "." ] 
			< Execute( "Previous Physical Name" ) >
			"\n"
		Pop
		"DROP CONSTRAINT "
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
		
	]
	[
		[
			FE::Option("FKConstraintInAlter")
			Set("var_Proceed", "false")
			Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
			[
				PushReference("Relationship_Ref")
				[
					ShouldGenerate
					PushReference("Child_Entity_Ref")
					[
						ShouldGenerate
						Set("var_Proceed", "true")
					]
					Pop
				]
				Pop
			]
		]
		[
			FE::IsAlterScriptGeneration
			Equal( Value( "var_Proceed" ), "false" )
			/*Generate if the object referenced by the deleted object has also been deleted.*/
			/*If the object referenced by the deleted object is still active, then check the Generate property on the referenced object*/

			IsDeleted
			@if ( IsPropertyModified( "Relationship_Ref" ) )
			{
				PushOldImage
				PushReference( "Relationship_Ref" )
				[
					/* The relationship referenced by the KeyGroup has been deleted */
					/* FK indexes are maintained as long as the relationship is active */
					IsDeleted
					IsPropertyModified( "Child_Entity_Ref" )
					PushOldImage
					    PushReference( "Child_Entity_Ref" )
					    [
						    @if ( IsDeleted )
						    {
					            /* The referenced Child Entity was also deleted */
						        Set( "var_Proceed", "true" )
						    }
						    @else
						    {
						        /* The referenced Child Entity is still active*/
						        ShouldGenerate
						        Set( "var_Proceed", "true" )
						    }
					    ]
					    Pop
					Pop
				]
				Pop
			}
		]
		[
			Equal( Value( "var_Proceed" ), "true" )
			OnceForObject( "Drop Constraint")
			FE::Bucket( "36" )			
			PushOwner
				"ALTER TABLE " 
				[< Execute("Previous Owner") > "." ] 
				< Execute( "Previous Physical Name" ) >
				"\n"
			Pop
			"DROP CONSTRAINT "
			PushReference( "Relationship_Ref" )
				< Execute( "Previous Physical Name" ) >
			Pop
			FE::EndOfStatement			
		]
		Remove( "var_Proceed" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Drop Default
	[
		[
			OnceForObject( "Drop Default" )
			[
				FE::IsAlterScriptGeneration 
				ShouldGenerate
				/* For each referring oDefaultConstraintUsage object, unbind the column. */
				
			    ForEachReference( "Dependent_Objects_Ref", "require_one" )
			    {
				    Execute( "Drop Default_Constraint_Usage" )
			    }
			]
	
			[
				IsPropertyFalse( "Generate_As_SQL_92_Format" )
				[
					/* Drop the default object.*/
					FE::Bucket( "5" )
					"DROP DEFAULT "	
					Execute( "Previous Physical Name" )
					FE::EndOfStatement
				]
			]
		]
	]
SPItemEnd

SPItemBegin [keep format] = Drop Default_Constraint_Usage
	[
		/* Unbind the default value. */
		[
		    PushOwner
			[
			    Equal( ObjectType, "Attribute" )
			    PushOwner
			    [
				    IsMatch( ObjectType, "Attribute", "Entity" )
				    Set( "var_OwnerIsAttribute", "true" )
			    ]
			    Pop
			]
			Pop
			Equal( Value( "var_OwnerIsAttribute" ), "true" )
			Equal(Execute( "Old Default Is SQL 92" ),"")
			IsNotInheritedFromUDD
			@ifnot(IsGlobalFlagSet("Drop Default_Constraint_Usage"))
			{
				OnceForObject( "Drop Default_Constraint_Usage" )
				FE::Bucket( "4" )
				"exec sp_unbindefault "
	
				PushOwner
					PushOwner 
				    	"'"
                    	[ <Execute("Previous Owner")> "." ] 
                    	QuotedName
					Pop
					"." 
					Property( "Physical_Name" ) 
					"'"
				Pop
				FE::EndOfStatement
			}
		]
	
		/* Unbind the default doamin value. */
		[
			PushOwner
			[
			    Equal( ObjectType, "Domain" ) 
			    Set( "var_OwnerIsDomain", "true" )
			]
			Pop
			
			Equal( Value( "var_OwnerIsDomain" ), "true" )
			Equal( Execute( "Old Default Is SQL 92" ), "" )
			OnceForObject( "Drop Default_Constraint_Usage" )
			FE::Bucket( "4" )
			SetGlobalFlag("Drop Default_Constraint_Usage")
			"exec sp_unbindefault "
			PushOwner
				"'" [ FE::OwnerOverride( "true" ) "." ]
				QuotedName "'"
			Pop
			FE::EndOfStatement
		]
	
	
		/* Pop back to original object if necessary. */
		[
		    Equal( ObjectType, "Default" ) 
		    Pop
		]
	
		/* Drop the column level default value.	*/
		[
			Equal( Value( "var_OwnerIsAttribute"), "true" )
			NotEqual( Execute( "Old Default Is SQL 92" ), "" )
			OnceForObject( "Drop Column Level Constraint Usage" )
			[
				FE::Bucket( "4" ) 
				"\n"
				PushOwner
					PushOwner
					    "ALTER TABLE " 
					    [ < Execute( "Previous Owner" ) > "." ] 
					    QuotedName
					Pop
				Pop
	
				" DROP CONSTRAINT " 
				< Execute( "Previous Physical Name" ) >
				FE::EndOfStatement
			]
		]
	
		/* Pop back to original object if necessary. */
		[
		    Equal( ObjectType, "Default" ) 
		    Pop
		]
	
		Remove( "var_OwnerIsAttribute")
		Remove( "var_OwnerIsDomain")
	]
SPItemEnd

SPItemBegin [keep format] = Drop Domain
	[
		FE::Option( "DropUserDefinedType" ) 
		LookupProperty( "Generate_As_User_Defined_Type", "true", "" )
		ShouldGenerate
		OnceForObject( "Drop Domain" )
		[
			FE::Bucket( "45" )
			"DROP TYPE " 
			Execute( "Previous Physical Name" )
			FE::EndOfStatement
		]
	]
SPItemEnd

SPItemBegin [keep format] = Drop Entity
	[
		OnceForObject( "Drop Entity" )
		
		[
			ForEachOwnee( "Key_Group" )
			{
				FE::Bucket( "38" )
				Execute( "Drop Key_Group" )
			}
		]
		
		/* Drop Fulltext indexes */
		[
			FE::Option( "DropTable" )
			FE::Bucket( "38" )
			ForEachOwnee( "SQLServer_Fulltext_Index" )
			{
				Execute( "Drop SQLServer_Fulltext_Index" )
			}
			
			ForEachOwnee( "SQLServer_XML_Index" )
			{
				Execute( "Drop SQLServer_XML_Index" )
			}
		]
	
		[
			ShouldGenerate 
			FE::Option( "DropTable" ) 
			FE::IsAlterScriptGeneration 
			ForEachOwnee( "Attribute" )
			{
				@ifnot ( IsCreated )
				{
					/*IsNullX([IsCreatedX "Newly Created - Suppress"])*/
					[
						/*PushObjectX("Default_Constraint_Usage" )*/
						ForEachOwnee( "Default_Constraint_Usage" )
						{
							@ifnot ( IsCreated )
							{
							    Execute( "Drop Default_Constraint_Usage" )
							}
						}
					]
					[
						ForEachOwnee( "Check_Constraint_Usage" )
						{
							@ifnot ( IsCreated )
							{
							    Execute( "Drop Check_Constraint_Usage" )
							}
						}
					]
				}
			}
			[
				ForEachOwnee( "Check_Constraint_Usage" )
				{
					@ifnot ( IsCreated )
					{
						[ Execute( "Drop Table Check Constraint Usage" ) ]
					}
				}
			]
		]
	
		[
			FE::Option( "DropTable" )
			SetGlobalFlag( ObjectId "Drop Entity" )
			[
				FE::IsSchemaGeneration
				FE::Bucket( "40" )
				"DROP TABLE " 
				[< Execute("Previous Owner") > "." ] 
				<Property( "Physical_Name" )>
				FE::EndOfStatement
			]
			
			[
				FE::IsAlterScriptGeneration
				[
					ForEachReference( "Parent_Relationships_Ref", "require_one" )
					{
						[
							IsDeleted
							PushReference( "Child_Entity_Ref" )
							[
								Equal( ObjectType, "View" ) 
								Execute( "Drop View" )
							]
							Pop
						]
					}
				]
	
				[
					ForEachReference( "Child_Relationships_Ref", "require_one" )
					{
						PushReference( "Child_Entity_Ref" )
						[
							Equal( ObjectType, "Entity" )
							Pop
							[
								ForEachReference( "Dependent_Objects_Ref", "require_one" )
								{
									/*Equal( ObjectType "Key_Group" )*/ /**/ /* comma missing? */
									Equal( ObjectType, "Key_Group" )

									Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" )
									[
										@ifnot ( IsCreated )
										{
										    Execute( "Drop Constraint" )
										}
									]
								}
							]
							PushReference( "Child_Entity_Ref" )
						]
						Pop
					}
				]
	
				[
					ForEachReference( "Parent_Relationships_Ref", "require_one" )
					{
						PushReference( "Parent_Entity_Ref" )
						[
							Equal( ObjectType, "Entity" )
							Pop
							[
								ForEachReference( "Dependent_Objects_Ref", "require_one" )
								{
									Equal( ObjectType, "Key_Group" )
									Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" )
									[
										@ifnot ( IsCreated )
										{
										    Execute( "Drop Constraint" )
										}
									]
								}
							]
							PushReference( "Parent_Entity_Ref" )
						]
						Pop
					}
				]
	
				[
					IsDeleted
					FE::Bucket( "40" )
					"DROP TABLE "
					[< Execute("Previous Owner") > "." ] 
					<Execute("Previous Physical Name")>
					FE::EndOfStatement
				]
				
				[	
					Set( "var_DomainDatatypeModified", "false" )
					
				    ForEachReference( "Columns_Order_Ref", "require_one" )
				    {
					    [
						    [
						        IsPropertyModified( "Parent_Domain_Ref" ) 
						        Set( "var_DomainDatatypeModified", "true" )
						    ]
				
						    PushReference( "Parent_Domain_Ref" )
						    [
						        IsPropertyModified( "Physical_Data_Type" ) 
							    Set( "var_DomainDatatypeModified", "true" )
						    ]
						    Pop
					    ]
				    }
					
				]
				
				@ifnot ( IsDeleted )
				{
					IsPropertyNotNull( "Columns_Order_Ref" ) 
					< Execute( "Table Has Insert Columns For Data Preservation" ) >
					FE::Bucket( "40" )
					[
					   @if ( Equal( Value( "var_DomainDatatypeModified" ), "false" ) )
					   {
						    "execute sp_rename "	
						    "'" 
						    [ < Execute( "Previous Owner" ) > "." ] 
						    <Execute( "Previous Physical Name" )>
					        "'" 
					        ", " 
					        "'"
					        <FE::TempTable( "Temporary" )>
					        "'"
						    FE::EndOfStatement
					   }
					   @else
					   {
						   [
							   "CREATE TABLE " 
							   [< Execute("Previous Owner") > "." ] 
							   FE::TempTable( "Temporary" )
							   "\n"
							   "("
							   
							    ForEachReference( "Columns_Order_Ref", "require_one" )
							    {
				                    @ifnot ( IsCreated )
				                    {
								        ListSeparator( ",\n" )
								        Property( "Physical_Name" ) " " 
								        Property( "Physical_Data_Type" ) 
								    }
							    }
								")"
								FE::EndOfStatement
							]
					
							[
								"INSERT INTO " 
								[< Execute("Previous Owner") > "." ] 
								FE::TempTable( "Temporary" )
								" ("
								
								    ForEachReference( "Columns_Order_Ref", "require_one" )
								    {
									    NotEqual( Execute( "Clause: AttributeDatatype" ) , "timestamp" )
									    ListSeparator( " ," )
									    NotEqual( ConversionFunction, "" )
								        Property( "Physical_Name" )
								    }
					            
								") SELECT "
					            
							    ForEachReference( "Columns_Order_Ref", "require_one" )
							    {
								    NotEqual( Execute( "Clause: AttributeDatatype" ), "timestamp" )
						            NotEqual( ConversionFunction, "" )
						            ListSeparator( " ," )
						            ConversionFunction
							    }
								
								" FROM " 
							    [ < Execute( "Previous Owner" ) > "." ] 
								Execute( "Previous Physical Name" )
								FE::EndOfStatement
							]
						}
					
					]
				}

				/*IsNotNullX([PropertyValueX("Columns_Order_Ref")],"<FALSE>" )*/
				@ifnot ( IsDeleted )
				{
					IsPropertyNotNull( "Columns_Order_Ref" )
					Equal( Value( "var_DomainDatatypeModified" ), "true" )
					
					FE::Bucket( "40" )
					"DROP TABLE " 
					[< Execute("Previous Owner") > "." ] 
					<Execute( "Previous Physical Name" )>
					FE::EndOfStatement
				}
				Remove( "var_DomainDatatypeModified" )
			]
		]
	]
SPItemEnd

SPItemBegin [keep format] = Drop Function
[
	ShouldGenerate
	OnceForObject( "Drop Function" )
    /* Make sure that FE options are turned on. */
    @if ( Equal( Property( "Type" ), "Model Level" ) )
    {
        FE::Option( "ModelDropFunction" )
        SetLocalFlag( "var_ShouldGenerate" )
    }
    @elseif ( Equal ( Property( "Type" ), "Table Level" ) )
    {
       /* FE option is checked by the caller object. */
        SetLocalFlag( "var_ShouldGenerate" )
    }
    
    @if ( IsLocalFlagSet( "var_ShouldGenerate" ) )
    {
        [ 
            FE::Bucket( "42" )
            "DROP FUNCTION " 
            [<Execute("Previous Owner")>"." ] 
            Execute( "Previous Physical Name" )
            FE::EndOfStatement
        ]
        ClearLocalFlag( "var_ShouldGenerate" )
    }
]
SPItemEnd

SPItemBegin [keep format] = Drop Key_Group
[
	/* Owner type can be either entity or join index (cached view). */

	Set( "var_OwnerType", "unknown" )
	[ 
		PushOwner 
			Set( "var_OwnerType", ObjectType ) 
		Pop 
	] 
	
	/* Make sure that the appropriate FE index option is selected. */
	Set( "var_KeyGroupType", Left( Property( "Key_Group_Type" ), "2" ) )
	@if ( Equal( Value( "var_KeyGroupType" ), "IF" ) )
	{
		Set( "var_KeyGroupType", "FK" )
	}
   
	[ 
		Equal( Value( "var_OwnerType" ), "Entity" )
			
		@if ( Equal( Value( "var_KeyGroupType" ), "PK" ) )
		{
			FE::Option( "DropPKIndex" )
			SetLocalFlag( "var_ShouldGenerate" )
		}
		@elseif ( Equal( Value( "var_KeyGroupType" ), "AK" ) )
		{
			FE::Option( "DropAKIndex" )
			SetLocalFlag( "var_ShouldGenerate" )
		}
		@elseif ( Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" ) )
		{
			FE::Option( "DropFKIndex" )
			SetLocalFlag( "var_ShouldGenerate" )
		}
		@elseif ( Equal( Value( "var_KeyGroupType" ), "IE" ) )
		{
			FE::Option( "DropIEIndex" )
			SetLocalFlag( "var_ShouldGenerate" )
			Set( "var_KeyGroupType", "FK" )
		}
	]
	[ 
		Equal( Value( "var_OwnerType" ), "Cached_View" )
		@if ( Equal( Value( "var_KeyGroupType" ), "AK" ) )
		{
			FE::Option( "DropCachedViewAlternateKeyIndex" )
			SetLocalFlag( "var_ShouldGenerate" )
		}
		@elseif ( Equal( Value( "var_KeyGroupType" ), "IE" ) )
		{
			FE::Option( "DropCachedViewInversionEntryIndex" )
			SetLocalFlag( "var_ShouldGenerate" )
		}			
	]
	Remove( "var_KeyGroupType" )  

	[ 
		FE::IsSchemaGeneration
		@if ( IsLocalFlagSet( "var_ShouldGenerate" ) )
		{
			ShouldGenerate
			OnceForObject( "Drop Key_Group" )
			FE::Bucket( "38" )

			"DROP INDEX " 
			[ FE::OwnerOverride( "true" ) "." ] 
			QuotedName
			" ON " 
			PushOwner 
				[ FE::OwnerOverride( "true" ) "." ] 
				QuotedName  
			Pop
			[   
				IsPropertyTrue("Is_Clustered")
				[" WITH ( ONLINE = " LookupProperty("Online", "true", "ON", "false", "OFF") " )" ]
			]

			FE::EndOfStatement

			ClearLocalFlag( "var_ShouldGenerate" )
		}
	]

	[ 
		FE::IsAlterScriptGeneration
		@if ( IsPropertyModified ( "Index_Members_Order_Ref" ) )
		{
			PushOldImage
			@if ( IsPropertyNotNull( "Index_Members_Order_Ref" ) )
			{
				SetLocalFlag( "Key Group Had Members", "1" )
			}
			Pop
		}
		@else
		{
			@if ( IsPropertyNotNull( "Index_Members_Order_Ref" ) )
			{
				SetLocalFlag( "Key Group Had Members" )
			}
		}
		@if(IsLocalFlagSet( "Key Group Had Members" ))
		{
			@if ( IsPropertyModified( "Key_Group_Type" ) )
            {
                PushOldImage
                @if ( Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" ) )
                { 
                    SetLocalFlag( "var_IndexWasUnique" )
                }
                @elseif ( Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" ) )
                {
                    SetLocalFlag( "var_IndexWasUnique" )
                }
                Pop
            }
            @else
            {
            	@ifnot( IsCreated )
            	{
            		SetLocalFlag( "var_IndexWasUnique" )
            	}
            }		
			@if ( IsLocalFlagSet( "var_IndexWasUnique" ) )
			{
				IsPropertyTrue( "Generate_As_Constraint" )
				Execute( "Drop Constraint" )
			}
	
			@if ( IsLocalFlagSet( "var_ShouldGenerate" ) )
			{
				ShouldGenerate
				OnceForObject( "Drop Key_Group" )
				FE::Bucket( "38" )
	
				"DROP INDEX " 
				[ 
					< Execute( "Previous Owner" ) > 
					"." 
				] 
				Execute( "Previous Physical Name" ) 
				" ON " 
				PushOwner 
					[ 
						< Execute( "Previous Owner" ) > 
						"." 
					] 
					Execute( "Previous Physical Name" )  
				Pop
				
				Set( "var_bClustered", "false" )
				[   
					@if( IsPropertyModified( "Is_Clustered" ) )
					{
						PushOldImage
						[
							IsPropertyTrue( "Is_Clustered" )
							Set( "var_bClustered", "true" )
						]
						Pop
					}
					@else
					{
						IsPropertyTrue( "Is_Clustered" ) 
						Set( "var_bClustered", "true" )
					}
					
					@if( Equal( Value( "var_bClustered" ), "true" ) )
					{
						@if( IsPropertyModified( "Online" ) )
						{
							PushOldImage
							[ 
								[" WITH ( ONLINE = " LookupProperty("Online", "true", "ON", "false", "OFF") " )" ]
							]
							Pop
						}
						@else
						{
							[" WITH ( ONLINE = " LookupProperty("Online", "true", "ON", "false", "OFF") " )" ]
						}
					}
				]
				Remove( "var_bClustered" )
				FE::EndOfStatement

				ClearLocalFlag( "var_ShouldGenerate" )
			}
		}
	]
	Remove( "var_OwnerType" )
]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Aggregate
	[
		FE::Option( "DropAggregate" )
		ShouldGenerate
		FE::Bucket( "42" )
		"DROP AGGREGATE "
		
		[ <Execute("Previous Owner")> "." ]
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Application_Role
	[
		FE::Option( "DropApplicationRole" )
		ShouldGenerate
		FE::Bucket( "42" )
		"DROP APPLICATION ROLE " 
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Assembly
	[
		FE::Option( "DropAssembly")
		ShouldGenerate
		FE::Bucket( "48" )
		"DROP ASSEMBLY "
		Execute( "Previous Physical Name" )
		"\n" 
		"WITH NO DEPENDENTS "
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Asymmetric_Key
	[
		FE::Option( "DropAsymmetricKey" )
		ShouldGenerate
		FE::Bucket( "47" )
		
		[
			Equal( Left( [ Execute( "Is Server Object" ) ], "2" ), "SO" )
			SetLocalFlag( "var_bServerObject" )
		]
		
		[ 
		    IsLocalFlagSet( "var_bServerObject" ) 
		    "EXEC ('" 
		    "USE master; \n" 
		]		
		
		"DROP ASYMMETRIC KEY "  
		< Execute( "Previous Physical Name" ) >

		[ 
		    IsLocalFlagSet( "var_bServerObject" ) 
		    ";\n')" 
		] /* close EXEC */
		
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Certificate
	[
		FE::Option( "DropCertificate" )
		ShouldGenerate
		FE::Bucket( "47" )

		[
			Equal( Left( [ Execute( "Is Server Object" ) ], "2" ), "SO" )
			SetLocalFlag( "var_bServerObject" )
		]

		[ 
		    IsLocalFlagSet( "var_bServerObject" ) 
		    "EXEC ('USE master;\n" 
		]
		
		"DROP CERTIFICATE " 
		< Execute( "Previous Physical Name" ) >

		[ 
		    IsLocalFlagSet( "var_bServerObject" ) 
		    ";\n')" 
		] 

		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Credential
	[
		FE::Option( "DropCredential" )
		ShouldGenerate
		FE::Bucket( "47" )
		"DROP CREDENTIAL " 
		
		/* Specify the name of the credential. */
		< Execute( "Previous Physical Name" ) >
		
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Database
[
	FE::Option( "DropDatabase" )
	ShouldGenerate
	FE::Bucket( "49" )
	"DROP DATABASE "
	< Execute( "Previous Physical Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Database_Role
	[
		FE::Option( "DropDatabaseRole" )
		ShouldGenerate
		FE::Bucket( "42" )
		"DROP ROLE " 
		
		/* Specify the name of the role.*/
		< Execute( "Previous Physical Name" ) > 
		
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Filegroup
[
	OnceForObject( "Drop SQLServer_Filegroup" )
	SetGlobalFlag( ObjectId "Drop SQLServer_Filegroup" )
	"ALTER DATABASE " 
	PushOwner 
	QuotedName
	Pop
	
	" REMOVE FILEGROUP "
	QuotedName
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Fulltext_Catalog
	[
		FE::Option( "DropFulltextCatalog" )
		ShouldGenerate
		FE::Bucket( "39" )
		"DROP  FULLTEXT CATALOG "
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Fulltext_Index
	[
		FE::Option( "DropFulltextIndex" )
		OnceForObject( "DropFulltextIndex" )
		"DROP  FULLTEXT INDEX ON "
		<
		    PushOwner( "Entity_Ref" ) 
		        Execute( "Previous Physical Name" ) 
		    Pop
		>
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Fulltext_Index_Column
	[
		/* If a fulltext index column is created, add it to it's owner */
		"ALTER FULLTEXT INDEX ON "
		/* Table containing the fulltext index */
		< 
		    PushOwner 
		    [ 
		        PushOwner 
		        [ 
		            Property( "Physical_Name" )
		        ] 
		        Pop 
		    ] 
		    Pop 
		>
		
		"\n" 
		"DROP (" 
		< Execute( "Previous Physical Name" ) > 
		")"
		[
		    "\n" 
		    IsPropertyTrue( "Do_Not_Populate" ) 
		    "WITH NO POPULATION"
		]

		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Login
	[
		FE::Option( "DropLogin" )
		ShouldGenerate
		FE::Bucket( "44" )
		"DROP LOGIN " 
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Partition_Function
	[
		FE::Option( "DropPartitionFunction" )
		ShouldGenerate
		FE::Bucket( "42" )
		
		"DROP PARTITION FUNCTION " 
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Partition_Scheme
	[
		FE::Option( "DropPartitionScheme" )
		ShouldGenerate
		FE::Bucket( "42" )
		
		"DROP PARTITION SCHEME " 
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_Symmetric_Key
[
	FE::Option( "DropSymmetricKey" )
	ShouldGenerate
	FE::Bucket( "42" )
	
	/* Drop the referenced Symmetric Keys */
	ForEachReference( "Symmetric_Keys_Ref" )
	{
		Execute( "Drop SQLServer_Symmetric_Key" )
	}
	OnceForObject( "Drop Symmetric Key" )
	
	"DROP SYMMETRIC KEY " 
	< Execute( "Previous Physical Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_XML_Index
	[
		FE::Option( "DropXMLIndex" )
		OnceForObject( "DropXMLIndex" )
		"DROP INDEX "
		Execute( "Previous Physical Name" )
		" ON "
		PushOwner
            [ FE::OwnerOverride( "true" ) "." ] 
            Property( "Physical_Name" )
		Pop
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop SQLServer_XML_Schema_Collection
	[
		FE::Option( "DropXMLSchemaCollection" )
		ShouldGenerate
		FE::Bucket( "42" )
		"DROP XML SCHEMA COLLECTION " 
		
		/* Specify the SQL identifier for the XML schema collection.*/
		[ FE::OwnerOverride( "true" ) "." ]
		< Execute( "Previous Physical Name" ) >
		
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop Schema
[
	FE::Option( "DropSchema" )
	ShouldGenerate
	FE::Bucket( "46" )
	"DROP SCHEMA "
	< Execute( "Previous Physical Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Stored_Procedure
	OnceForObject( [ Repush( "1" ) ObjectId Pop ] "Drop Stored_Procedure" )
	FE::Bucket( "100" )
	[
		"IF EXISTS \n"
		"     (SELECT * FROM SYSOBJECTS WHERE ID = OBJECT_ID('" [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" ) "')) \n"
		"DROP PROCEDURE " 
		[ < Execute( "Previous Owner" ) > "." ]  
		Execute( "Previous Physical Name" )
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop Synonym
	[
		FE::Option( "ModelDropSynonym")		
		"DROP SYNONYM "
		
		/* Name of the Synonym */
		[ FE::OwnerOverride( "true" ) "." ]
		< Execute( "Previous Physical Name" ) >
		
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop Table Check Constraint Usage
	[
		/* Drop the table level constraint for the validation rule. */
		[
			/*IsNotNullX(Execute( "Validation Is SQL 92" ), "<True>")*/ 
			< Execute( "Validation Is SQL 92" ) >
			OnceForObject( "Drop Check_Constraint_Usage" )
			[
				FE::Bucket( "3" )
	
				PushOwner
					"ALTER TABLE " 
					[ < Execute( "Previous Owner" ) > "." ] 
					QuotedName 
					" DROP CONSTRAINT "
				Pop
				Property( "Physical_Name" ) /*Constraint Name*/
				FE::EndOfStatement
			]
		]
	]
SPItemEnd

SPItemBegin [keep format] = Drop Trigger
	[
		OnceForObject( "Drop Trigger" )
		Set( "var_bProceed", "false" )
		[
			PushOwner
	        Switch( ObjectType )
	        {
	            Choose( "Entity" )
	            {
	                FE::Option( "TableDropTrigger" )
	                Set( "var_bProceed", "true" )
	            }
	            Choose( "View")
	            {	
	                FE::Option( "ViewDropTrigger" )
	                Set( "var_bProceed", "true" )
	            }
	            Choose( "SQLServer_Database" )
	            {
	                FE::Option( "DropDatabaseTrigger" )
	                Set( "var_bProceed", "true" )
	            }
	            Choose( "Model" )
	            {
	                FE::Option( "DropServerTrigger" )
	                Set( "var_bProceed", "true" )
	            }
	        }
	        Pop
        ]
		@if ( Equal( Value( "var_bProceed" ), "true" ) )
        {
			/*FESetStringX("Drop Trigger" )*/
			SetGlobalFlag( ObjectId "Drop Trigger" )
			ShouldGenerate
			FE::Bucket( "40" ) 
			"DROP TRIGGER "
			[ < Execute("Previous Owner") > "." ] Execute("Previous Physical Name")
			FE::EndOfStatement
		}
		Remove( "var_bProceed" )
	]
SPItemEnd

SPItemBegin [keep format] = Drop User_Id
	[
		FE::Option( "DropUserId" )
		ShouldGenerate
		FE::Bucket( "43" )
		"DROP USER "
		/* Name of the User */
		< Execute( "Previous Physical Name" ) >
		FE::EndOfStatement
	]
SPItemEnd

SPItemBegin [keep format] = Drop Validation_Rule
	[
			ShouldGenerate 
			FE::Option( "CreateRule" )
			OnceForObject( "Drop Validation_Rule" )
			[
				FE::IsAlterScriptGeneration
				/* For each referring oCheckConstraintUsage object, unbind the column. */
				[
					ForEachReference( "Dependent_Objects_Ref", "require_one" )
					{
						PushOwner
							Set( "var_ObjectType", ObjectType ) 
						Pop
						[
							IsMatch( Value( "var_ObjectType" ), "Attribute","Domain" ) 
							Execute( "Drop Check_Constraint_Usage" )
						]
						[
							Equal( Value( "var_ObjectType" ), "Entity" ) 
							Execute( "Drop Table Check Constraint Usage" )
						]
						Remove( "var_ObjectType" )
					}
				]
	
			]
			[
				/*LookupProperty( "Generate_As_SQL_92_Format", "<TRUE>", "<FALSE>", "<TRUE>" )*/
				IsPropertyFalse( "Generate_As_SQL_92_Format" )
				/* Drop the validation rule object. */
				FE::Bucket( "4" )
				"DROP RULE " 
				Execute( "Previous Physical Name" )
                FE::EndOfStatement
			]
	]

SPItemEnd

SPItemBegin [keep format] = Drop View
	[
		[
			OnceForObject( "Drop View" ) 
			[
				FE::IsAlterScriptGeneration
				
			    ForEachReference( "Parent_Relationships_Ref", "require_one" )
			    {
				    [
					    PushReference( "Child_Entity_Ref" )
					    [
					        Equal( ObjectType, "View" ) 
					        Execute( "Drop View" )
					    ]
					    Pop
				    ]
			    }
				
			]
			[
				FE::Bucket( "40" )  
				FE::Option( "DropView" )
				[
					"DROP VIEW " 
					[ < Execute( "Previous Owner" ) > "." ] 
					< Execute( "Previous Name" ) >
					FE::EndOfStatement
				]
			]
	
			[
				FE::Bucket( "95" ) 
				"\n"
				
			    ForEachReference( "Stored_Procedures_Ref", "require_one" )
			    {
				    IsPropertyTrue( "Type" )
				    [
				        FE::Option( "ViewDropStoredProcedure" ) 
				        Execute( "Drop Stored_Procedure" )
				    ]
				    [
				        FE::Option( "ViewCreateStoredProcedure" ) 
				        Execute( "Create Stored_Procedure" )
				    ]
			    }
				
			]	
		]
	]
SPItemEnd

SPItemBegin [keep format] = ExecuteConstraint
	Execute( "Clause: PKConstraint" )
	Execute( "Clause: AKConstraint" )
	Execute( "Clause: FKConstraint" )
SPItemEnd

SPItemBegin [keep format] = Generate Check_Constraint_Usage
	Execute( "Drop Check_Constraint_Usage"   )
	Execute( "Create Check_Constraint_Usage" )
SPItemEnd

SPItemBegin [keep format] = Generate Default
	[ 
		ShouldGenerate
		[  
			FE::IsSchemaGeneration
			Execute( "Create Default" )
		]
	
		[
			FE::IsAlterScriptGeneration
	
			/* Drop the default object. */
			Execute( "Drop Default" )
	
			/* Re-create the default object. */
			Execute( "Create Default" )
	
			/* For each referring oDefaultConstraintUsage object, rebind the column. */
			ForEachReference( "Dependent_Objects_Ref" )
			{
				Execute( "Create Default_Constraint_Usage" )
			}
		]
	]
SPItemEnd

SPItemBegin [keep format] = Generate Default_Constraint_Usage
	Execute( "Drop Default_Constraint_Usage" )
	Execute( "Create Default_Constraint_Usage" )
SPItemEnd

SPItemBegin [keep format] = Generate Domain
	[
		[
			FE::IsSchemaGeneration
			Execute( "Drop Domain" )
			Execute( "Create Domain" )
		]
	
		[
			FE::IsAlterScriptGeneration
			/* Drop the domain. */
			Execute( "Drop Domain" )
	
			/* Re-create the domain. */
			Execute( "Create Domain" )
	
			/* For each referring oAttribute object, recreate the table. */
			ForEachReference( "Dependent_Objects_Ref" )
			{
				[
					Equal( ObjectType, "Attribute" )
					[
						PushOwner
						[ 
						    Equal( ObjectType, "Entity" ) 
						    [ Execute( "Generate Entity" ) ] 
						]
						Pop
					]
				]
			}
		]
	
	 ]
SPItemEnd

SPItemBegin [keep format] = Generate Entity
	[
		OnceForObject( "Generate Entity" )
		[
			FE::IsSchemaGeneration
			[ Execute( "Drop Entity" ) ]
			[ Execute( "Create Entity" ) ]
		]
	
		[
			FE::IsAlterScriptGeneration
			/* Add this entity in the data preservation list. */
			[ FE::ActivateDataPreservation() ]
	
			/*Create the temp table and copy the data into it*/
			[ FE::DataPreservationOption( "PreserveData" ) ]
	
			Execute( "Drop Entity" )
			Execute( "Create Entity" )
	
			/*Insert the data from temp table to the new modified table*/
			[
				FE::DataPreservationOption( "PreserveData" )
				FE::Bucket( "93" ) 
				"\n"
				Execute( "Insert Columns For Data Preservation" )
				FE::DataPreservationOption( "RegisterEntity" )
			]
	
			/*Drop the temp table*/
			[
				FE::DataPreservationOption( "DropTempTable" )
				FE::Bucket( "140" ) 
				"\n"
				FE::Option( "DropTable" ) 
				
				@ifnot ( Equal( Execute( "Table Has Insert Columns For Data Preservation" ), "" ) )
				{
				    "DROP TABLE " 
				    [ FE::OwnerOverride( "true" ) "." ] 
				    FE::TempTable( "Temporary" )
				    FE::EndOfStatement
				}

				Remove( "var_ColsForDataPres" )
			]
		]
	]
SPItemEnd

SPItemBegin [keep format] = Generate Function

	Execute( "Drop Function" )
	Execute( "Create Function" )

SPItemEnd

SPItemBegin [keep format] = Generate Key_Group
	[
		Equal([PushOwner ObjectType Pop],"Entity")
		Execute( "Drop Key_Group" )
		Execute( "Create Key_Group" )
		
        [ /* If this is Alter script, drop recreate FK constraints when PK or AK constraint is dropped and recreated. */
            FE::IsAlterScriptGeneration
            
            
            /*Make sure the context key group is of type PK or AK.*/
            @if ( Equal( Left( Property( "Key_Group_Type" ), 2 ), "PK" ) )
            {
                SetLocalFlag( "var_bRecreateFK" )
            }
            
            @if ( Equal( Left( Property( "Key_Group_Type" ), 2 ), "AK" ) )
            {
                SetLocalFlag( "var_bRecreateFK" )
            }
            
            @if ( IsLocalFlagSet( "var_bRecreateFK" ) )
            {
                /* Check if the context constraint can be dropped.*/
                @ifnot ( AreAllOwneesCreated( "Key_Group_Member" ) )
                {
                    SetLocalFlag( "var_CanDropConstraint" )
                }

                [
                    IsLocalFlagSet( "var_CanDropConstraint" )
        		    
                    /* Identify the relationship migrating the PK. */
                    
                    ForEachReference( "Dependent_Objects_Ref", "require_one" )
                    {
                            Equal( ObjectType, "Relationship" )
                            [
                                /* Identify the FK key group created as a side effect of relationship creation. */
                                ForEachReference( "Dependent_Objects_Ref", "require_one" )
                                {
                                    Equal( ObjectType, "Key_Group" )
                                    Equal( Left( Property( "Key_Group_Type" ), 2 ), "IF" ) 
                                    [
                                        /* Execute Drop recreate constraint on the FK*. */
                                        Execute( "Drop Constraint" )
                                        Execute( "Create Constraint" )
                                    ]
                    
                                }
                            ]
                    }
                    
                ]
                ClearLocalFlag( "var_CanDropConstraint" )
            }
            ClearLocalFlag( "var_bRecreateFK" )
	    ]
    ]
SPItemEnd

SPItemBegin [keep format] = Generate Model
	[	
		OnceForObject( "Generate Model" )
		[
			FE::Option( "QuoteName" )
			FE::Bucket( "1" ) 
			"\n" 
			"set quoted_identifier on"
			FE::EndOfStatement
		]
		
		/* Emit the Use database statement if a database filter has been set up. */
		[
			FE::Bucket( "51" ) 
			< FE::EmitUseDatabaseStatement >
			FE::EndOfStatement
		]
		
		[
			FE::Option( "ModelPreScript" )
			ForEachOwnee( "Script_Template","Object_Order" )
			{
				[
					ShouldGenerate
					FE::Bucket( "1" )
					IsPropertyTrue( "Generate_As_Pre_Script" )
					Equal( Property( "Type" ), "Model Level" )
                    FE::ExpandERwinMacro( "Template_Code" )
					FE::EndOfStatement( "true" )
				]
			}
		]
	
		[
			FE::IsSchemaGeneration 
			FE::Bucket( "100" )
			"\n"
			ForEachReference( "Source_Objects_Ref" )
			{
				ShouldGenerate
				[ 
				    Equal( ObjectType, "Stored_Procedure" )
					Equal( Property( "Type", "no_translate" ), "0" ) /* model - level */
					[
					    FE::Option( "ModelDropProcedure" ) 
					    Execute( "Drop Stored_Procedure" )
					]
					[
					    FE::Option( "ModelCreateProcedure" )	
					    Execute( "Create Stored_Procedure" )
					]
				]
				[ 
				    Equal( ObjectType, "Function" )
					Equal( Property( "Type", "no_translate" ), "0" ) /* model - level */
					[
					    FE::Option( "ModelDropFunction" ) 
					    Execute( "Drop Function" )
					]
					[
					    FE::Option( "ModelCreateFunction" )	
					    Execute( "Create Function" )
					]
				]
			}
		]

		[
			FE::Option( "ModelPostScript" )
			ForEachOwnee("Script_Template","Object_Order" )
			{
				[
					ShouldGenerate
					FE::Bucket( "120" )
					IsPropertyFalse( "Generate_As_Pre_Script" )
					Equal( Property( "Type" ), "Model Level" )
                    FE::ExpandERwinMacro( "Template_Code" )
					FE::EndOfStatement( "true" )
				]
			}
		]
		
		/* Specify the server level privileges. */
		[ 
			FE::Bucket( "150" ) 
			ForEachOwnee( "Permission" )
			{
				Execute( "Create Permission" )
			}
		]
	]
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Aggregate
	Execute( "Drop SQLServer_Aggregate" )
	Execute( "Create SQLServer_Aggregate" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Application_Role
	Execute( "Drop SQLServer_Application_Role" )
	Execute( "Create SQLServer_Application_Role" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Assembly
	Execute( "Drop SQLServer_Assembly")
	Execute( "Create SQLServer_Assembly")
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Asymmetric_Key
	Execute( "Drop SQLServer_Asymmetric_Key" )
	Execute( "Create SQLServer_Asymmetric_Key" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Certificate
	Execute( "Drop SQLServer_Certificate" )
	Execute( "Create SQLServer_Certificate" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Credential
	Execute( "Drop SQLServer_Credential" )
	Execute( "Create SQLServer_Credential" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Database
	Execute( "Drop SQLServer_Database" )
	Execute( "Create SQLServer_Database" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Database_Role
	Execute( "Drop SQLServer_Database_Role" )
	Execute( "Create SQLServer_Database_Role" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Filegroup
[
	[ Execute( "Drop SQLServer_Filegroup"   ) ]
	[ Execute( "Create SQLServer_Filegroup" ) ]
]
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Fulltext_Catalog
	Execute( "Drop SQLServer_Fulltext_Catalog" )
	Execute( "Create SQLServer_Fulltext_Catalog" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Fulltext_Index
	Execute( "Drop SQLServer_Fulltext_Index" )
	Execute( "Create SQLServer_Fulltext_Index" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Login
	Execute( "Drop SQLServer_Login" )
	Execute( "Create SQLServer_Login" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Partition_Function
	Execute( "Drop SQLServer_Partition_Function" )
	Execute( "Create SQLServer_Partition_Function" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Partition_Scheme
	Execute( "Drop SQLServer_Partition_Scheme" )
	Execute( "Create SQLServer_Partition_Scheme" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_Symmetric_Key
	Execute( "Drop SQLServer_Symmetric_Key" )
	Execute( "Create SQLServer_Symmetric_Key" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_XML_Index
	Execute( "Drop SQLServer_XML_Index" )
	Execute( "Create SQLServer_XML_Index" )
SPItemEnd

SPItemBegin [keep format] = Generate SQLServer_XML_Schema_Collection
	Execute( "Drop SQLServer_XML_Schema_Collection" )
	Execute( "Create SQLServer_XML_Schema_Collection" )
SPItemEnd

SPItemBegin [keep format] = Generate Schema
	Execute( "Drop Schema" )
	Execute( "Create Schema" )
SPItemEnd

SPItemBegin [keep format] = Generate Stored_Procedure
	[
		OnceForObject("Generate Stored_Procedure")
		FE::Bucket( "100" )
		Execute( "Drop Stored_Procedure" )
		Execute( "Create Stored_Procedure" )
	]
SPItemEnd

SPItemBegin [keep format] = Generate Synonym
	Execute( "Drop Synonym")
	Execute( "Create Synonym")
SPItemEnd

SPItemBegin [keep format] = Generate Table Check Constraint Usage
    [
        Execute( "Drop Table Check Constraint Usage" )
        Execute( "Create Table Check Constraint Usage" )
    ]
SPItemEnd

SPItemBegin [keep format] = Generate Trigger
	/*[ Execute( "Create Trigger" ) ]*/ /*?*/ /* This must have been backwards. */
	[ Execute( "Drop Trigger"  ) ]
	[ Execute( "Create Trigger" ) ]

SPItemEnd

SPItemBegin [keep format] = Generate User_Id
	Execute( "Drop User_Id" )
	Execute( "Create User_Id" )
SPItemEnd

SPItemBegin [keep format] = Generate Validation_Rule
	[
		ShouldGenerate
		[
			FE::IsSchemaGeneration
			Execute( "Create Validation_Rule" )
		]
	
		[
			FE::IsAlterScriptGeneration
			/* Drop the validation rule object. */
			Execute( "Drop Validation_Rule" )
			/* Re-create the validation rule object. */
			Execute( "Create Validation_Rule" )
			/* For each referring oCheckConstraintUsage object, rebind the column. */
			[
				ForEachReference( "Dependent_Objects_Ref" )
				{
					PushOwner 
					    Set( "var_ObjectType", ObjectType ) 
					Pop
					[
						IsMatch( Value( "var_ObjectType" ), "Attribute", "Domain" ) 
						Execute( "Create Check_Constraint_Usage" )
					]
					[
						Equal( Value( "var_ObjectType" ), "Entity" ) 
						Execute( "Create Table Check Constraint Usage" )
					]
					Remove( "var_ObjectType" )
				}
			]
		]
	]
SPItemEnd

SPItemBegin [keep format] = Generate View
[
	Execute( "Drop View" )
	Execute( "Create View" )
]
SPItemEnd

SPItemBegin [keep format] = Insert Columns For Data Preservation
[  
    	FE::Option( "DropTable")

        NotEqual( Execute( "Table Has Insert Columns For Data Preservation" ), "" )
        
        [	
			Set("var_DomainDatatypeModified", "false")
			ForEachReference( "Columns_Order_Ref", "require_one" )
			{
				[
					[
					    @if(IsPropertyModified("Parent_Domain_Ref"))
					    {
					        Set("var_DomainDatatypeModified", "true")
					    }
		
					    PushReference("Parent_Domain_Ref")
					    [
						    [
						        @if(IsPropertyModified("Physical_Data_Type"))
						        {
						            Set("var_DomainDatatypeModified", "true")
						        }
						    ]
					    ]
					    Pop
					]
				]
			}
		]

        		
		Set( "var_bIdentity", "false" )
		/* Check if the table has columns with the Identity option selected */
		[
			ForEachReference( "Columns_Order_Ref" )
			{
				Equal( Property( "Null_Option_Type", "no_translate" ), "8" )
				Set( "var_bIdentity", "true" )
			}
		]

		/* Check if all columns in table have datatype timestamp. */
		Set( "var_bAllTimestmp", "true" )
		
		
	    ForEachReference( "Columns_Order_Ref", "require_one" )
	    {
		    [
			    NotEqual( Execute( "Clause: AttributeDatatype" ), "timestamp" )
			    Set( "var_bAllTimestmp", "false" )
		    ]
	    }
		
		
		[
		    /* Suppress INSERT INTO statement generation if all columns in table use TIMESTAMP datatype*/
			Equal( Value( "var_bAllTimestmp"), "false" )
			
			/* Prepare the insert query for the data preservation. */
		    [
			    Equal( Value( "var_bIdentity" ), "true" )
		 	    "SET IDENTITY_INSERT "	
		 	    [ FE::OwnerOverride( "true" ) "." ] 
		 	    Property( "Physical_Name" ) 
		 	    " ON"
		 	    "\n"
		    ]
		
		    [
		        Equal(Value("var_DomainDatatypeModified"), "false")
		        "INSERT INTO " 
		        [ FE::OwnerOverride( "true" ) "." ]
		        < QuotedName >
		        " ("
    		    
	            ForEachReference( "Columns_Order_Ref", "require_one" )
	            {
			            NotEqual( Execute( "Clause: AttributeDatatype" ), "timestamp" )
			            NotEqual( ConversionFunction, "" )
			            ListSeparator( ", " )
			            Property( "Physical_Name" )
	            }
		        ") SELECT "
    		    
	            ForEachReference( "Columns_Order_Ref", "require_one" )
	            {
			            NotEqual( Execute( "Clause: AttributeDatatype" ), "timestamp" )
			            NotEqual( ConversionFunction, "" )
			            ListSeparator( ", " )
			            ConversionFunction
	            }
		        " FROM " 
		        [ < Execute( "Previous Owner" ) > "." ]
		        FE::TempTable( "Temporary" )
		        [
		            " WHERE " 
		            FE::DataPreservationOption( "WhereClause" )
		        ]    
		    ]
		    
		    [
		        Equal(Value("var_DomainDatatypeModified"), "true")
		        "INSERT INTO " 
		        [ FE::OwnerOverride( "true" ) "." ]
		        < QuotedName >
		        " ("
			        ForEachReference( "Columns_Order_Ref", "require_one" )
			        {
				        [
					        NotEqual( Execute( "Clause: AttributeDatatype" ), "timestamp" )
			                NotEqual( ConversionFunction, "" )
			                ListSeparator( ", " )
			                Property( "Physical_Name" )
				        ]
			        }
		        ") SELECT "
				        ForEachReference( "Columns_Order_Ref", "require_one" )
				        {
					        [
						        NotEqual( Execute( "Clause: AttributeDatatype" ), "timestamp" )
						        NotEqual( ConversionFunction, "" )
						        ListSeparator( ", " )
						        Execute( "Previous Physical Name" )
					        ]
				        }
		        " FROM " 
		            [ < Execute( "Previous Owner" ) > "." ] 
		            FE::TempTable( "Temporary" )
		            [" WHERE " FE::DataPreservationOption("WhereClause")]   
		    ]

	        "\n"

		    [
			    Equal( Value( "var_bIdentity" ), "true" )
		 	    "SET IDENTITY_INSERT "	
		 	    [ FE::OwnerOverride( "true" ) "." ] 
		 	    Property( "Physical_Name" ) 
		 	    " OFF"
		    ]
		    FE::EndOfStatement
		    Remove("var_DomainDatatypeModified")
		]
		Remove( "var_bAllTimestmp" )
		Remove( "var_bIdentity" )
]
SPItemEnd

SPItemBegin [keep format] = Is Server Object
[
	ForEachReference( "Dependent_Objects_Ref" )
	{
		Equal( ObjectType, "SQLServer_Login" ) 
		"SO"
	}
]
SPItemEnd

SPItemBegin [keep format] = Old Default Is SQL 92
[
	[
		FE::IsSchemaGeneration
		PushReference("Default_Ref")
		[
			LookupProperty("Generate_As_SQL_92_Format", "true","SQL 92")
			Pop
		]
	]
	[
		FE::IsAlterScriptGeneration
		[
			[
				@ifnot(IsPropertyModified("Default_Ref"))
				{
					PushReference("Default_Ref")
					[
						@ifnot(IsPropertyModified("Generate_As_SQL_92_Format"))
						{
							LookupProperty("Generate_As_SQL_92_Format", "true","SQL 92")
						}
					]
					Pop
				}
			]
			[
				IsPropertyModified("Default_Ref")
				PushOldImage
				[
					@ifnot(IsPropertyModified("Generate_As_SQL_92_Format"))
					{
						LookupProperty("Generate_As_SQL_92_Format", "true","SQL 92")
					}
				]
				Pop
			]
		]
		[
			[
				@ifnot(IsPropertyModified("Default_Ref"))
				{
					PushReference("Default_Ref")
					[
						IsPropertyModified("Generate_As_SQL_92_Format")
						PushOldImage
						LookupProperty("Generate_As_SQL_92_Format",	"true","SQL 92")
						Pop
					]
					Pop
				}
			]
			[
				IsPropertyModified("Default_Ref")
				PushOldReference("Default_Ref")
				[
					IsPropertyModified("Generate_As_SQL_92_Format")
					PushOldImage
					LookupProperty("Generate_As_SQL_92_Format",	"true","SQL 92")
					Pop
				]
				Pop
			]
		]
	]
]
SPItemEnd

SPItemBegin [keep format] = Old Validation Is SQL 92
[
    FE::IsSchemaGeneration
	PushReference( "Validation_Rule_Ref" )
		[ LookupProperty( "Generate_As_SQL_92_Format", "true", "SQL 92" ) ]
	Pop
]
[
	FE::IsAlterScriptGeneration
	[
		@if ( IsPropertyModified( "Validation_Rule_Ref" ) ) 
		{
			PushOldImage
			    PushReference( "Validation_Rule_Ref" )
			    [
				    @if ( IsPropertyModified( "Generate_As_SQL_92_Format" ) )
				    {
				        PushOldImage
				            LookupProperty( "Generate_As_SQL_92_Format", "true", "SQL 92" )
				        Pop
				    }
				    @else
				    {
				        LookupProperty( "Generate_As_SQL_92_Format", "true", "SQL 92" )
				    }
			    ]
			    Pop
			Pop
		}
		@else
		{
			PushReference( "Validation_Rule_Ref" )
			[
				@if ( IsPropertyModified( "Generate_As_SQL_92_Format" ) )
				{
				    PushOldImage
				        LookupProperty( "Generate_As_SQL_92_Format", "true", "SQL 92" )
				    Pop
				}
				@else
				{
				    LookupProperty( "Generate_As_SQL_92_Format", "true", "SQL 92" )
				}
			]
			Pop
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Previous Name
[ 
    FE::IsSchemaGeneration
    QuotedName
]

[ 
    FE::IsAlterScriptGeneration
    @if ( IsPropertyModified( "Name" ) )
    {
        PushOldImage 
            QuotedName 
        Pop
    }
    @else
    {
        QuotedName
    }
]
SPItemEnd

SPItemBegin [keep format] = Previous Owner
[ 
    FE::Option( "SpecifyOwner" )
    [ 
        FE::IsSchemaGeneration
        FE::OwnerOverride( "true" ) 
    ]

    [ 
        FE::IsAlterScriptGeneration
        /* By default, we are reading DB owner from the model. */
        SetLocalFlag( "Default To Model" )
    
        /* Is DB owner overriden by the user?                            */
        /* FE::OwnerOverride will emit the owner name if it's overriden. */
        @if ( FE::OwnerOverride )
        {
            ClearLocalFlag( "Default To Model" )
        }
    
        @if ( IsLocalFlagSet( "Default To Model" ) )
        {
            /* Fetch the DB owner from the model.                                  */
            /* NOTE: some targets may use DB Owner property instead of Schema Ref. */
            @if ( IsPropertyModified( "Schema_Ref" ) )
            {
                PushOldImage
                [ 
                    PushReference( "Schema_Ref" )
                        [ Execute( "Previous Name" ) ]
                    Pop
                ]
                Pop
            }
            @else
            {
                PushReference( "Schema_Ref" )
                    [ Execute( "Previous Name" ) ]
                Pop
            }
            
            ClearLocalFlag( "Default To Model" )
        }
    
    ]
]
SPItemEnd

SPItemBegin [keep format] = Previous Physical Name
[ 
    FE::IsSchemaGeneration
    QuotedName
]
[ 
    FE::IsAlterScriptGeneration
    @if ( IsPropertyModified( "Name", "Physical_Name" ) )
    {
        PushOldImage 
            QuotedName 
        Pop
    }
    @else
    {
        QuotedName
    }
]
SPItemEnd

SPItemBegin [keep format] = Previous Property Value
[ 
    FE::IsSchemaGeneration
    Property( "%1" )
]

[ 
    FE::IsAlterScriptGeneration
    @if ( IsPropertyModified( "%1" ) )
    {
        PushOldImage 
            Property( "%1" ) 
        Pop
    }
    @else
    {
        Property( "%1" )
    }
]
SPItemEnd

SPItemBegin [keep format] = Suppress Constraint Name
[
	PushReference( "Relationship_Ref" )
    [ 
        /*IsNotNullX([Equal( Property( "Physical_Name" ), "is_a")], "<FALSE>" )*/ /**/
        @if ( Equal( Property( "Physical_Name" ), "is_a" ) ) /*?*/ /* should we use "Left" here? */
        {
	        PushReference( "Parent_Entity_Ref" )
	        [ 
	            Equal( ObjectType, "Subtype_Symbol" ) 
	            "Suppress Constraint Name" 
	        ]
		    Pop
	    }
    ]
	Pop
]
SPItemEnd

SPItemBegin [keep format] = Table Has Insert Columns For Data Preservation
[

	ForEachReference( "Columns_Order_Ref", "require_one" )
	{
		@ifnot ( IsCreated )
		{
		    ListSeparator( ", " )
		    QuotedName
		}
	}
]
SPItemEnd

SPItemBegin [keep format] = Validation Is SQL 92
[
	PushReference( "Validation_Rule_Ref" )
	    [ LookupProperty( "Generate_As_SQL_92_Format", "true","SQL 92" ) ]
	Pop
]
SPItemEnd

SPItemBegin [keep format] = xx OLD  Drop Key Group

	Set( "var_KeyGroupType", Left( Property( "Key_Group_Type" ), "2" ) )
	@if ( Equal( Value( "var_KeyGroupType" ), "IF" ) )
	{
	    Set( "var_KeyGroupType", "FK" )
	}
	[
		FE::IsAlterScriptGeneration
		@ifnot ( AreAllOwneesCreated( "Key_Group_Member" ) )
		{
			Set( "var_Proceed", "false" )
			[
		    @if ( IsPropertyNotNull( "Index_Members_Order_Ref" ) )
		    {
		        Set( "var_Proceed", "true" ) 
		    }
		    ]
			[ 
			    AreAllOwneesDeleted( "Key_Group_Member" ) 
			    Set( "var_Proceed", "true" ) 
			]
			
			Equal( Value( "var_Proceed" ), "true" )
			Remove( "var_Proceed" )
			
			@if ( IsPropertyTrue( "Generate_As_Constraint" ) )
			{
				@if ( IsMatch( Value( "var_KeyGroupType" ), "PK", "AK" ) )
				{ 
					Execute( "Drop Constraint" ) 
				}
				@else
				{
				    @ifnot ( IsCreated )
				    {
					    PushOldImage
					    @if ( IsPropertyNull( "Key_Group_Type" ) )
					    {
					        Pop
					        Execute( "Drop Constraint" )
					    }
					    @else
					    {
					        Pop
					    }
					}
				}
			}
			@else
			{
				Set( "var_Proceed", "true" )
				FE::Option( "Drop" Value( "var_KeyGroupType" ) "Index" )
				[
					Equal( Value( "var_KeyGroupType" ), "FK" )
					FE::Option( "DropFKIndex" )
					PushReference( "Relationship_Ref" ) 
					[
						@ifnot( ShouldGenerate ) 
						{
						    Set( "var_Proceed", "false" ) 
						}
					]
					Pop
				]		
				[
					Equal( Value( "var_Proceed" ), "true" )
					FE::Bucket( "38" )
					"DROP INDEX "
					Execute( "Previous Physical Name" )
					" ON "
					PushOwner
					    Execute( "Previous Physical Name" )
					Pop
					FE::EndOfStatement
				]
				Remove( "var_Proceed" )
			}
		}
	]

	[
		FE::IsSchemaGeneration
		OnceForObject( "Drop Key_Group" )
		ShouldGenerate
		
		Set( "var_Proceed", "true" )
		FE::Option( "Drop" Value( "var_KeyGroupType" ) "Index" )
		[
			Equal( Left( Property( "Key_Group_Type" ), 2 ), "FK" )
			FE::Option( "DropFKIndex" )
			PushReference( "Relationship_Ref" ) 
			    @ifnot ( ShouldGenerate )
			    {
			        Set( "var_Proceed", "false" )
			    }
			Pop
		]
		[
			Equal( Value( "var_Proceed" ), "true" )
			FE::Bucket( "38" )
			"DROP INDEX "
			QuotedName
			" ON "
			PushOwner
            [ FE::OwnerOverride( "true" ) "." ] 
			QuotedName
			Pop
			FE::EndOfStatement
		]
		Remove( "var_Proceed" )
	]
	Remove( "var_KeyGroupType" )

SPItemEnd

